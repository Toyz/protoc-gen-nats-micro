// Code generated by protoc-gen-nats-micro. DO NOT EDIT.

package v1

import (
	"context"
	"errors"
	"fmt"
	"log"
	"os"
	"strconv"
	"sync"
	"time"
	"github.com/nats-io/nats.go"
	"github.com/nats-io/nats.go/jetstream"
	"github.com/nats-io/nats.go/micro"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/encoding/protojson"
)

// StreamDemoServiceError represents a structured error from StreamDemoService
type StreamDemoServiceError struct {
	Code    string // Error code (e.g., "INVALID_ARGUMENT", "NOT_FOUND", "INTERNAL")
	Message string // Human-readable error message
	Method  string // The method that failed
}

func (e *StreamDemoServiceError) Error() string {
	return fmt.Sprintf("[%s] %s: %s", e.Code, e.Method, e.Message)
}

// NatsErrorCode returns the NATS error code for this error
func (e *StreamDemoServiceError) NatsErrorCode() string {
	return e.Code
}

// NatsErrorMessage returns the NATS error message for this error
func (e *StreamDemoServiceError) NatsErrorMessage() string {
	return e.Message
}

// NatsErrorData returns optional error data (nil for basic errors)
func (e *StreamDemoServiceError) NatsErrorData() []byte {
	return nil
}

// Service-specific error code constants (use shared constants from service_shared_nats.pb.go)
const (
	StreamDemoServiceErrCodeInvalidArgument  = ErrCodeInvalidArgument
	StreamDemoServiceErrCodeNotFound         = ErrCodeNotFound
	StreamDemoServiceErrCodeAlreadyExists    = ErrCodeAlreadyExists
	StreamDemoServiceErrCodePermissionDenied = ErrCodePermissionDenied
	StreamDemoServiceErrCodeUnauthenticated  = ErrCodeUnauthenticated
	StreamDemoServiceErrCodeInternal         = ErrCodeInternal
	StreamDemoServiceErrCodeUnavailable      = ErrCodeUnavailable
)

// IsStreamDemoServiceInvalidArgument checks if the error is an invalid argument error
func IsStreamDemoServiceInvalidArgument(err error) bool {
	var svcErr *StreamDemoServiceError
	return errors.As(err, &svcErr) && svcErr.Code == StreamDemoServiceErrCodeInvalidArgument
}

// IsStreamDemoServiceNotFound checks if the error is a not found error
func IsStreamDemoServiceNotFound(err error) bool {
	var svcErr *StreamDemoServiceError
	return errors.As(err, &svcErr) && svcErr.Code == StreamDemoServiceErrCodeNotFound
}

// IsStreamDemoServiceAlreadyExists checks if the error is an already exists error
func IsStreamDemoServiceAlreadyExists(err error) bool {
	var svcErr *StreamDemoServiceError
	return errors.As(err, &svcErr) && svcErr.Code == StreamDemoServiceErrCodeAlreadyExists
}

// IsStreamDemoServicePermissionDenied checks if the error is a permission denied error
func IsStreamDemoServicePermissionDenied(err error) bool {
	var svcErr *StreamDemoServiceError
	return errors.As(err, &svcErr) && svcErr.Code == StreamDemoServiceErrCodePermissionDenied
}

// IsStreamDemoServiceUnauthenticated checks if the error is an unauthenticated error
func IsStreamDemoServiceUnauthenticated(err error) bool {
	var svcErr *StreamDemoServiceError
	return errors.As(err, &svcErr) && svcErr.Code == StreamDemoServiceErrCodeUnauthenticated
}

// IsStreamDemoServiceInternal checks if the error is an internal error
func IsStreamDemoServiceInternal(err error) bool {
	var svcErr *StreamDemoServiceError
	return errors.As(err, &svcErr) && svcErr.Code == StreamDemoServiceErrCodeInternal
}

// IsStreamDemoServiceUnavailable checks if the error is an unavailable error
func IsStreamDemoServiceUnavailable(err error) bool {
	var svcErr *StreamDemoServiceError
	return errors.As(err, &svcErr) && svcErr.Code == StreamDemoServiceErrCodeUnavailable
}

// GetStreamDemoServiceErrorCode extracts the error code from an error, returns empty string if not a StreamDemoServiceError
func GetStreamDemoServiceErrorCode(err error) string {
	var svcErr *StreamDemoServiceError
	if errors.As(err, &svcErr) {
		return svcErr.Code
	}
	return ""
}

// NewStreamDemoServiceInvalidArgumentError creates a new invalid argument error
func NewStreamDemoServiceInvalidArgumentError(method, message string) error {
	return &StreamDemoServiceError{Code: StreamDemoServiceErrCodeInvalidArgument, Method: method, Message: message}
}

// NewStreamDemoServiceNotFoundError creates a new not found error
func NewStreamDemoServiceNotFoundError(method, message string) error {
	return &StreamDemoServiceError{Code: StreamDemoServiceErrCodeNotFound, Method: method, Message: message}
}

// NewStreamDemoServiceAlreadyExistsError creates a new already exists error
func NewStreamDemoServiceAlreadyExistsError(method, message string) error {
	return &StreamDemoServiceError{Code: StreamDemoServiceErrCodeAlreadyExists, Method: method, Message: message}
}

// NewStreamDemoServicePermissionDeniedError creates a new permission denied error
func NewStreamDemoServicePermissionDeniedError(method, message string) error {
	return &StreamDemoServiceError{Code: StreamDemoServiceErrCodePermissionDenied, Method: method, Message: message}
}

// NewStreamDemoServiceUnauthenticatedError creates a new unauthenticated error
func NewStreamDemoServiceUnauthenticatedError(method, message string) error {
	return &StreamDemoServiceError{Code: StreamDemoServiceErrCodeUnauthenticated, Method: method, Message: message}
}

// NewStreamDemoServiceInternalError creates a new internal error
func NewStreamDemoServiceInternalError(method, message string) error {
	return &StreamDemoServiceError{Code: StreamDemoServiceErrCodeInternal, Method: method, Message: message}
}

// NewStreamDemoServiceUnavailableError creates a new unavailable error
func NewStreamDemoServiceUnavailableError(method, message string) error {
	return &StreamDemoServiceError{Code: StreamDemoServiceErrCodeUnavailable, Method: method, Message: message}
}

// Stream protocol header constants
const (
	natsStreamSeqHeader   = "Nats-Stream-Seq"
	natsStreamEndHeader   = "Nats-Stream-End"
	natsStreamInboxHeader = "Nats-Stream-Inbox"
	natsStreamErrorHeader = "Nats-Stream-Error"
)

// ServerStreamSender is the server-side interface for sending streaming responses
type ServerStreamSender interface {
	// Send publishes one message to the client
	Send(data []byte) error
	// SendMsg serializes and sends a proto message to the client
	SendMsg(msg proto.Message, useJSON bool) error
	// Close sends the end-of-stream marker to the client
	Close() error
	// CloseWithError sends an error and end-of-stream marker to the client
	CloseWithError(code string, message string) error
}

// serverStreamSender implements ServerStreamSender using NATS publish
type serverStreamSender struct {
	nc      *nats.Conn
	subject string // The client's reply inbox
	seq     int
	mu      sync.Mutex
	closed  bool
}

func newServerStreamSender(nc *nats.Conn, replySubject string) *serverStreamSender {
	return &serverStreamSender{
		nc:      nc,
		subject: replySubject,
		seq:     0,
	}
}

func (s *serverStreamSender) Send(data []byte) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	if s.closed {
		return errors.New("stream is closed")
	}
	s.seq++
	msg := &nats.Msg{
		Subject: s.subject,
		Data:    data,
		Header:  nats.Header{},
	}
	msg.Header.Set(natsStreamSeqHeader, strconv.Itoa(s.seq))
	return s.nc.PublishMsg(msg)
}

func (s *serverStreamSender) SendMsg(msg proto.Message, useJSON bool) error {
	var data []byte
	var err error
	if useJSON {
		data, err = protojson.Marshal(msg)
	} else {
		data, err = proto.Marshal(msg)
	}
	if err != nil {
		return fmt.Errorf("failed to marshal stream message: %w", err)
	}
	return s.Send(data)
}

func (s *serverStreamSender) Close() error {
	s.mu.Lock()
	defer s.mu.Unlock()
	if s.closed {
		return nil
	}
	s.closed = true
	msg := &nats.Msg{
		Subject: s.subject,
		Data:    nil,
		Header:  nats.Header{},
	}
	msg.Header.Set(natsStreamEndHeader, "true")
	return s.nc.PublishMsg(msg)
}

func (s *serverStreamSender) CloseWithError(code string, message string) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	if s.closed {
		return nil
	}
	s.closed = true
	msg := &nats.Msg{
		Subject: s.subject,
		Data:    nil,
		Header:  nats.Header{},
	}
	msg.Header.Set(natsStreamEndHeader, "true")
	msg.Header.Set("Status", code)
	msg.Header.Set("Description", message)
	return s.nc.PublishMsg(msg)
}

// ClientStreamReceiver receives streaming messages from a server
type ClientStreamReceiver struct {
	sub     *nats.Subscription
	msgCh   chan *nats.Msg
	done    chan struct{}
	lastErr error
	ordered bool
	lastSeq int
	mu      sync.Mutex
}

func newClientStreamReceiver(nc *nats.Conn, inbox string, ordered bool) (*ClientStreamReceiver, error) {
	msgCh := make(chan *nats.Msg, 64)
	done := make(chan struct{})

	sub, err := nc.Subscribe(inbox, func(msg *nats.Msg) {
		// Check for end-of-stream
		if msg.Header.Get(natsStreamEndHeader) == "true" {
			close(done)
			return
		}
		select {
		case msgCh <- msg:
		case <-done:
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to subscribe to stream inbox: %w", err)
	}

	return &ClientStreamReceiver{
		sub:     sub,
		msgCh:   msgCh,
		done:    done,
		ordered: ordered,
	}, nil
}

// Recv blocks until the next message arrives or the stream ends.
// Returns nil, io.EOF when the stream is complete.
// Returns the raw NATS message for caller to decode.
func (r *ClientStreamReceiver) Recv(ctx context.Context) (*nats.Msg, error) {
	select {
	case msg, ok := <-r.msgCh:
		if !ok {
			return nil, fmt.Errorf("stream closed")
		}
		// Check for error in stream
		if status := msg.Header.Get("Status"); status != "" {
			desc := msg.Header.Get("Description")
			return nil, fmt.Errorf("stream error [%s]: %s", status, desc)
		}
		// Enforce ordering if requested
		if r.ordered {
			seqStr := msg.Header.Get(natsStreamSeqHeader)
			if seqStr != "" {
				seq, _ := strconv.Atoi(seqStr)
				r.mu.Lock()
				expected := r.lastSeq + 1
				r.lastSeq = seq
				r.mu.Unlock()
				if seq != expected {
					return nil, fmt.Errorf("out-of-order stream message: got seq %d, expected %d", seq, expected)
				}
			}
		}
		return msg, nil
	case <-r.done:
		return nil, fmt.Errorf("EOF")
	case <-ctx.Done():
		return nil, ctx.Err()
	}
}

// Close unsubscribes from the stream
func (r *ClientStreamReceiver) Close() error {
	return r.sub.Unsubscribe()
}

// Suppress unused import warnings
var (
	_ = strconv.Itoa
	_ = sync.Mutex{}
)

// StreamDemoServiceNats is the NATS service interface for StreamDemoService
type StreamDemoServiceNats interface {
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	CountUp(context.Context, *CountUpRequest, *StreamDemoService_CountUp_Stream) error
	Sum(context.Context, *StreamDemoService_Sum_Stream) (*SumResponse, error)
	Chat(context.Context, *StreamDemoService_Chat_Stream) error
}

// StreamDemoServiceEndpointInfo describes a service endpoint
type StreamDemoServiceEndpointInfo struct {
	Name    string `json:"name"`    // Method name (e.g., "CreateProduct")
	Subject string `json:"subject"` // NATS subject (e.g., "api.v1.create_product")
}

// StreamDemoServiceService is the interface for the registered NATS micro service
// This interface allows for easier dependency injection and testing
type StreamDemoServiceService interface {
	micro.Service
	Endpoints() []StreamDemoServiceEndpointInfo
}

// streamDemoServiceService is the concrete implementation of StreamDemoServiceService
type streamDemoServiceService struct {
	micro.Service
	subjectPrefix string
}

// Endpoints returns information about all service endpoints
// This is useful for debugging, monitoring, and service discovery
func (s *streamDemoServiceService) Endpoints() []StreamDemoServiceEndpointInfo {
	return []StreamDemoServiceEndpointInfo{
		{Name: "Ping", Subject: s.subjectPrefix + ".ping"},
		{Name: "CountUp", Subject: s.subjectPrefix + ".count_up"},
		{Name: "Sum", Subject: s.subjectPrefix + ".sum"},
		{Name: "Chat", Subject: s.subjectPrefix + ".chat"},
	}
}

// RegisterStreamDemoServiceHandlers registers the service with NATS micro handlers
// Service: stream_demo_service v1.0.0
// Description: Demonstrates server, client, and bidi streaming RPCs
// Subject prefix: api.v1.stream
// Configuration options: WithName(), WithVersion(), WithDescription(), WithSubjectPrefix(), WithTimeout()
// Metadata options: WithMetadata() (replace), WithAdditionalMetadata() (merge)
// Handler options: WithStatsHandler(), WithDoneHandler(), WithErrorHandler()
//
// Endpoint metadata can be configured via proto options (nats.micro.endpoint).metadata
func RegisterStreamDemoServiceHandlers(nc *nats.Conn, impl StreamDemoServiceNats, opts ...RegisterOption) (StreamDemoServiceService, error) {
	cfg := &registerConfig{
		name:          "stream_demo_service",
		version:       "1.0.0",
		description:   "Demonstrates server, client, and bidi streaming RPCs",
		subjectPrefix: "api.v1.stream",
		timeout:       0 * time.Second, // Service-level timeout (0 = no timeout)
		metadata:      map[string]string{},
	}
	for _, opt := range opts {
		opt(cfg)
	}

	svc, err := micro.AddService(nc, micro.Config{
		Name:         cfg.name,
		Version:      cfg.version,
		Metadata:     cfg.metadata,
		Description:  cfg.description,
		StatsHandler: cfg.statsHandler,
		DoneHandler:  cfg.doneHandler,
		ErrorHandler: cfg.errorHandler,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to add service: %w", err)
	}

	// Chain server interceptors
	var chainedInterceptor UnaryServerInterceptor
	if len(cfg.serverInterceptors) > 0 {
		chainedInterceptor = chainUnaryServerInterceptors(cfg.serverInterceptors)
	}

	handlers := &streamDemoServiceHandlers{
		nc:             nc,
		impl:           impl,
		serviceTimeout: cfg.timeout,
		useJSON:        false,
		interceptor:    chainedInterceptor,
		js:             cfg.js,
	}

	// Auto-create KV and Object Store buckets if JetStream is available
	if cfg.js != nil {
		ctx := context.Background()
		_ = ctx
	}

	// Map of endpoint names to their handlers
	endpoints := map[string]micro.Handler{

		"ping": micro.HandlerFunc(handlers.Ping),

		"count_up": micro.HandlerFunc(handlers.CountUp),

		"sum": micro.HandlerFunc(handlers.Sum),

		"chat": micro.HandlerFunc(handlers.Chat),
	}

	// Map of endpoint names to their metadata
	endpointMetadata := map[string]map[string]string{

		"ping": {},

		"count_up": {},

		"sum": {},

		"chat": {},
	}

	// Use interface to handle both Service and Group
	type endpointAdder interface {
		AddEndpoint(string, micro.Handler, ...micro.EndpointOpt) error
	}

	var adder endpointAdder = svc
	if cfg.subjectPrefix != "" {
		adder = svc.AddGroup(cfg.subjectPrefix)
	}

	// Register all endpoints with their metadata
	for name, handler := range endpoints {
		opts := []micro.EndpointOpt{}
		if metadata, exists := endpointMetadata[name]; exists && len(metadata) > 0 {
			opts = append(opts, micro.WithEndpointMetadata(metadata))
		}
		if err := adder.AddEndpoint(name, handler, opts...); err != nil {
			return nil, fmt.Errorf("failed to add endpoint %s: %w", name, err)
		}
	}

	return &streamDemoServiceService{
		Service:       svc,
		subjectPrefix: cfg.subjectPrefix,
	}, nil
}

// streamDemoServiceHandlers wraps the service implementation with NATS handlers
type streamDemoServiceHandlers struct {
	nc             *nats.Conn // NATS connection for streaming
	impl           StreamDemoServiceNats
	serviceTimeout time.Duration          // Default timeout for all endpoints
	useJSON        bool                   // Use JSON encoding instead of binary protobuf
	interceptor    UnaryServerInterceptor // Chained interceptors
	js             jetstream.JetStream    // Optional JetStream context for KV/ObjectStore
}

func (h *streamDemoServiceHandlers) Ping(req micro.Request) {
	// Determine effective timeout: endpoint-specific timeout overrides service timeout
	// If endpoint timeout is set (> 0), use it; otherwise use service timeout
	timeout := h.serviceTimeout
	timeout = 5 * time.Second // Endpoint-specific timeout

	// Create context with timeout if configured, otherwise use background context
	ctx := context.Background()
	var cancel context.CancelFunc
	if timeout > 0 {
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}

	// Add incoming NATS headers to context so service methods can access them
	if req.Headers() != nil {
		ctx = WithIncomingHeaders(ctx, req.Headers())
	}

	// Initialize outgoing headers pointer in context so interceptors can set response headers
	outgoingHeadersPtr := &nats.Header{}
	ctx = context.WithValue(ctx, outgoingHeadersKey, outgoingHeadersPtr)

	var msg PingRequest
	if h.useJSON {
		if err := protojson.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(StreamDemoServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode JSON request: %v", err), nil)
			return
		}
	} else {
		if err := proto.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(StreamDemoServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode request: %v", err), nil)
			return
		}
	}

	// Define the handler function
	handler := func(ctx context.Context, request interface{}) (interface{}, error) {
		typedReq, ok := request.(*PingRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type")
		}
		return h.impl.Ping(ctx, typedReq)
	}

	// Execute through interceptor chain if configured
	var resp interface{}
	var err error
	if h.interceptor != nil {
		info := &UnaryServerInfo{
			Service: "StreamDemoService",
			Method:  "Ping",
			Subject: "api.v1.stream.ping",
		}
		resp, err = h.interceptor(ctx, &msg, info, handler)
	} else {
		resp, err = handler(ctx, &msg)
	}
	if err != nil {
		// Check if error implements custom status code/message/data methods
		code := StreamDemoServiceErrCodeInternal
		message := err.Error()
		var data []byte

		// Check for NatsErrorCode() string method
		if coder, ok := err.(interface{ NatsErrorCode() string }); ok {
			code = coder.NatsErrorCode()
		}
		// Check for NatsErrorMessage() string method
		if messager, ok := err.(interface{ NatsErrorMessage() string }); ok {
			message = messager.NatsErrorMessage()
		}
		// Check for NatsErrorData() []byte method
		if dataProvider, ok := err.(interface{ NatsErrorData() []byte }); ok {
			data = dataProvider.NatsErrorData()
		}

		req.Error(code, message, data)
		return
	}

	// Type assert response back to the expected type
	typedResp, ok := resp.(*PingResponse)
	if !ok {
		req.Error(StreamDemoServiceErrCodeInternal, "invalid response type from handler", nil)
		return
	}

	var data []byte
	if h.useJSON {
		data, err = protojson.Marshal(typedResp)
		if err != nil {
			req.Error(StreamDemoServiceErrCodeInternal, fmt.Sprintf("failed to encode JSON response: %v", err), nil)
			return
		}
	} else {
		data, err = proto.Marshal(typedResp)
		if err != nil {
			req.Error(StreamDemoServiceErrCodeInternal, fmt.Sprintf("failed to encode response: %v", err), nil)
			return
		}
	}

	// Check if context has outgoing headers set by interceptors
	// Read from the pointer that was initialized at the start
	var outgoingHeaders nats.Header
	if headersPtr, ok := ctx.Value(outgoingHeadersKey).(*nats.Header); ok && headersPtr != nil {
		outgoingHeaders = *headersPtr
	}

	if len(outgoingHeaders) > 0 {
		// Send response with headers using micro.WithHeaders
		// Convert nats.Header to micro.Headers (they are the same underlying type)
		if err := req.Respond(data, micro.WithHeaders(micro.Headers(outgoingHeaders))); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for Ping: %v\n", err)
		}
	} else {
		// Send response without headers
		if err := req.Respond(data); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for Ping: %v\n", err)
		}
	}
}

// CountUp handles server-side streaming RPC.
// Client sends a single request; server streams back multiple responses.
func (h *streamDemoServiceHandlers) CountUp(req micro.Request) {
	ctx := context.Background()

	if req.Headers() != nil {
		ctx = WithIncomingHeaders(ctx, req.Headers())
	}

	var msg CountUpRequest
	if h.useJSON {
		if err := protojson.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(StreamDemoServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode request: %v", err), nil)
			return
		}
	} else {
		if err := proto.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(StreamDemoServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode request: %v", err), nil)
			return
		}
	}

	// Get the client's reply subject from the NATS request
	replySubject := req.Headers().Get("Reply-To")
	if replySubject == "" {
		// Fall back to using the NATS request reply subject
		// We need to signal to the client that we're starting a stream
		// First, acknowledge the request by responding with the stream inbox
		inbox := nats.NewInbox()
		replySubject = inbox
		ackHeader := nats.Header{}
		ackHeader.Set(natsStreamInboxHeader, inbox)
		req.Respond(nil, micro.WithHeaders(micro.Headers(ackHeader)))
	}

	sender := newServerStreamSender(h.nc, replySubject)
	stream := &StreamDemoService_CountUp_Stream{
		sender:  sender,
		useJSON: h.useJSON,
	}

	if err := h.impl.CountUp(ctx, &msg, stream); err != nil {
		sender.CloseWithError(StreamDemoServiceErrCodeInternal, err.Error())
		return
	}
	sender.Close()
}

// Sum handles client-side streaming RPC.
// Client streams multiple requests; server responds once.
func (h *streamDemoServiceHandlers) Sum(req micro.Request) {
	ctx := context.Background()

	if req.Headers() != nil {
		ctx = WithIncomingHeaders(ctx, req.Headers())
	}

	// Create an inbox for receiving the client's stream messages
	inbox := nats.NewInbox()
	receiver, err := newClientStreamReceiver(h.nc, inbox, false)
	if err != nil {
		req.Error(StreamDemoServiceErrCodeInternal, fmt.Sprintf("failed to setup stream: %v", err), nil)
		return
	}
	defer receiver.Close()

	// Tell the client where to send stream messages
	ackHeader := nats.Header{}
	ackHeader.Set(natsStreamInboxHeader, inbox)
	req.Respond(nil, micro.WithHeaders(micro.Headers(ackHeader)))

	stream := &StreamDemoService_Sum_Stream{
		receiver: receiver,
		useJSON:  h.useJSON,
	}

	resp, err := h.impl.Sum(ctx, stream)
	if err != nil {
		// Cannot send error via req since we already responded with ack
		log.Printf("[nats-micro] ERROR: Sum client stream handler failed: %v", err)
		return
	}

	// Send final response back via the original reply subject
	var data []byte
	if h.useJSON {
		data, err = protojson.Marshal(resp)
	} else {
		data, err = proto.Marshal(resp)
	}
	if err != nil {
		log.Printf("[nats-micro] ERROR: failed to marshal Sum response: %v", err)
		return
	}

	// Publish the final response to the client's reply inbox
	// The client will have subscribed for the reply
	replySubject := req.Headers().Get("Reply-To")
	if replySubject != "" {
		h.nc.Publish(replySubject, data)
	}
}

// Chat handles bidirectional streaming RPC.
// Both client and server can send and receive messages concurrently.
func (h *streamDemoServiceHandlers) Chat(req micro.Request) {
	ctx := context.Background()

	if req.Headers() != nil {
		ctx = WithIncomingHeaders(ctx, req.Headers())
	}

	// Create inbox for receiving client stream messages
	serverInbox := nats.NewInbox()
	receiver, err := newClientStreamReceiver(h.nc, serverInbox, false)
	if err != nil {
		req.Error(StreamDemoServiceErrCodeInternal, fmt.Sprintf("failed to setup stream: %v", err), nil)
		return
	}
	defer receiver.Close()

	// Get/create the reply subject for serverâ†’client messages
	clientInbox := req.Headers().Get("Reply-To")
	if clientInbox == "" {
		clientInbox = nats.NewInbox()
	}

	// Tell the client where to send its stream messages and where we'll send ours
	ackHeader := nats.Header{}
	ackHeader.Set(natsStreamInboxHeader, serverInbox)
	req.Respond(nil, micro.WithHeaders(micro.Headers(ackHeader)))

	sender := newServerStreamSender(h.nc, clientInbox)
	stream := &StreamDemoService_Chat_Stream{
		sender:   sender,
		receiver: receiver,
		useJSON:  h.useJSON,
	}

	if err := h.impl.Chat(ctx, stream); err != nil {
		sender.CloseWithError(StreamDemoServiceErrCodeInternal, err.Error())
		return
	}
	sender.Close()
}

// StreamDemoService_CountUp_Stream is the server-side stream for CountUp.
// The server calls Send() to push responses to the client.
type StreamDemoService_CountUp_Stream struct {
	sender  ServerStreamSender
	useJSON bool
}

// Send serializes and sends a response message to the client.
func (s *StreamDemoService_CountUp_Stream) Send(msg *CountUpResponse) error {
	return s.sender.SendMsg(msg, s.useJSON)
}

// Close sends the end-of-stream marker.
func (s *StreamDemoService_CountUp_Stream) Close() error {
	return s.sender.Close()
}

// CloseWithError sends an error and closes the stream.
func (s *StreamDemoService_CountUp_Stream) CloseWithError(code string, message string) error {
	return s.sender.CloseWithError(code, message)
}

// StreamDemoService_Sum_Stream is the server-side client-streaming handler for Sum.
// The server calls Recv() to read messages from the client.
type StreamDemoService_Sum_Stream struct {
	receiver *ClientStreamReceiver
	useJSON  bool
}

// Recv blocks until the next client message arrives.
func (s *StreamDemoService_Sum_Stream) Recv(ctx context.Context) (*SumRequest, error) {
	natsMsg, err := s.receiver.Recv(ctx)
	if err != nil {
		return nil, err
	}
	var msg SumRequest
	if s.useJSON {
		if err := protojson.Unmarshal(natsMsg.Data, &msg); err != nil {
			return nil, fmt.Errorf("failed to decode stream message: %w", err)
		}
	} else {
		if err := proto.Unmarshal(natsMsg.Data, &msg); err != nil {
			return nil, fmt.Errorf("failed to decode stream message: %w", err)
		}
	}
	return &msg, nil
}

// Close unsubscribes from client messages.
func (s *StreamDemoService_Sum_Stream) Close() error {
	return s.receiver.Close()
}

// StreamDemoService_Chat_Stream is the bidirectional stream for Chat.
type StreamDemoService_Chat_Stream struct {
	sender   ServerStreamSender
	receiver *ClientStreamReceiver
	useJSON  bool
}

// Send serializes and sends a response message to the client.
func (s *StreamDemoService_Chat_Stream) Send(msg *ChatMessage) error {
	return s.sender.SendMsg(msg, s.useJSON)
}

// Recv blocks until the next client message arrives.
func (s *StreamDemoService_Chat_Stream) Recv(ctx context.Context) (*ChatMessage, error) {
	natsMsg, err := s.receiver.Recv(ctx)
	if err != nil {
		return nil, err
	}
	var msg ChatMessage
	if s.useJSON {
		if err := protojson.Unmarshal(natsMsg.Data, &msg); err != nil {
			return nil, fmt.Errorf("failed to decode stream message: %w", err)
		}
	} else {
		if err := proto.Unmarshal(natsMsg.Data, &msg); err != nil {
			return nil, fmt.Errorf("failed to decode stream message: %w", err)
		}
	}
	return &msg, nil
}

// CloseSend sends the end-of-stream marker to the client.
func (s *StreamDemoService_Chat_Stream) CloseSend() error {
	return s.sender.Close()
}

// CloseRecv unsubscribes from client messages.
func (s *StreamDemoService_Chat_Stream) CloseRecv() error {
	return s.receiver.Close()
}

// StreamDemoServiceNatsClientInterface is the interface for the NATS client
// This interface allows for easier dependency injection and testing
type StreamDemoServiceNatsClientInterface interface {
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	CountUp(ctx context.Context, req *CountUpRequest) (*StreamDemoService_CountUp_ClientStream, error)
	Sum(ctx context.Context) (*StreamDemoService_Sum_ClientStream, error)
	Chat(ctx context.Context) (*StreamDemoService_Chat_ClientStream, error)
	Endpoints() []StreamDemoServiceEndpointInfo
}

// StreamDemoServiceNatsClient is the concrete implementation of StreamDemoServiceNatsClientInterface
type StreamDemoServiceNatsClient struct {
	nc            *nats.Conn
	subjectPrefix string
	useJSON       bool                   // Use JSON encoding instead of binary protobuf
	interceptor   UnaryClientInterceptor // Chained interceptors
	js            jetstream.JetStream    // Optional JetStream for KV/ObjectStore reads
}

// NewStreamDemoServiceNatsClient creates a new NATS client for StreamDemoService.
// The client sends requests over NATS using protobuf serialization (or JSON if configured).
func NewStreamDemoServiceNatsClient(nc *nats.Conn, opts ...NatsClientOption) StreamDemoServiceNatsClientInterface {
	cfg := &natsClientConfig{
		subjectPrefix: "api.v1.stream",
	}
	for _, opt := range opts {
		opt.applyNatsClientOption(cfg)
	}

	// Chain client interceptors
	var chainedInterceptor UnaryClientInterceptor
	if len(cfg.clientInterceptors) > 0 {
		chainedInterceptor = chainUnaryClientInterceptors(cfg.clientInterceptors)
	}

	c := &StreamDemoServiceNatsClient{
		nc:            nc,
		subjectPrefix: cfg.subjectPrefix,
		useJSON:       false,
		interceptor:   chainedInterceptor,
		js:            cfg.js,
	}
	return c
}

// Ping sends a Ping request to the service via NATS.
// Returns an error if the request fails or the service returns an error.
func (c *StreamDemoServiceNatsClient) Ping(ctx context.Context, req *PingRequest) (*PingResponse, error) {
	method := "Ping"

	// Pointer to store response headers - stored in context so invoker can update it
	responseHeadersPtr := &nats.Header{}

	// Add the response headers pointer to context so invoker can populate it
	// Interceptors can then read the headers from the same context
	ctx = context.WithValue(ctx, responseHeadersKey, responseHeadersPtr)

	// Define the invoker function that performs the actual NATS call
	invoker := func(invokerCtx context.Context, method string, request, reply interface{}) error {
		subject := c.subjectPrefix + ".ping"

		// Marshal request
		typedReq, ok := request.(*PingRequest)
		if !ok {
			return fmt.Errorf("invalid request type")
		}

		var data []byte
		var err error
		if c.useJSON {
			data, err = protojson.Marshal(typedReq)
		} else {
			data, err = proto.Marshal(typedReq)
		}
		if err != nil {
			return err
		}

		// Extract outgoing headers from context and attach to NATS message
		var msg *nats.Msg
		if headers := OutgoingHeaders(invokerCtx); headers != nil {
			msg, err = c.nc.RequestMsgWithContext(invokerCtx, &nats.Msg{
				Subject: subject,
				Data:    data,
				Header:  headers,
			})
		} else {
			msg, err = c.nc.RequestWithContext(invokerCtx, subject, data)
		}
		if err != nil {
			return err
		}

		// Store response headers in the pointer from context
		if msg.Header != nil && len(msg.Header) > 0 {
			if headersPtr, ok := invokerCtx.Value(responseHeadersKey).(*nats.Header); ok && headersPtr != nil {
				*headersPtr = msg.Header
			}
		} // Check if this is an error response from the service
		if msg.Header.Get("Status") != "" {
			code := msg.Header.Get("Status")
			description := msg.Header.Get("Description")
			return &StreamDemoServiceError{
				Code:    code,
				Method:  method,
				Message: description,
			}
		}

		// Unmarshal response
		typedReply, ok := reply.(*PingResponse)
		if !ok {
			return fmt.Errorf("invalid reply type")
		}

		if c.useJSON {
			err = protojson.Unmarshal(msg.Data, typedReply)
		} else {
			err = proto.Unmarshal(msg.Data, typedReply)
		}
		return err
	}

	var resp PingResponse

	// Execute through interceptor chain if configured
	var err error
	if c.interceptor != nil {
		err = c.interceptor(ctx, method, req, &resp, invoker)
	} else {
		err = invoker(ctx, method, req, &resp)
	}

	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// StreamDemoService_CountUp_ClientStream is the client-side stream receiver for CountUp.
type StreamDemoService_CountUp_ClientStream struct {
	receiver *ClientStreamReceiver
	useJSON  bool
}

// Recv blocks until the next response message arrives from the server.
// Returns an error containing "EOF" when the stream is complete.
func (s *StreamDemoService_CountUp_ClientStream) Recv(ctx context.Context) (*CountUpResponse, error) {
	msg, err := s.receiver.Recv(ctx)
	if err != nil {
		return nil, err
	}
	var resp CountUpResponse
	if s.useJSON {
		if err := protojson.Unmarshal(msg.Data, &resp); err != nil {
			return nil, fmt.Errorf("failed to decode stream message: %w", err)
		}
	} else {
		if err := proto.Unmarshal(msg.Data, &resp); err != nil {
			return nil, fmt.Errorf("failed to decode stream message: %w", err)
		}
	}
	return &resp, nil
}

// Close unsubscribes from the stream.
func (s *StreamDemoService_CountUp_ClientStream) Close() error {
	return s.receiver.Close()
}

// CountUp initiates a server-streaming RPC call.
// Returns a stream that yields responses from the server.
func (c *StreamDemoServiceNatsClient) CountUp(ctx context.Context, req *CountUpRequest) (*StreamDemoService_CountUp_ClientStream, error) {
	subject := c.subjectPrefix + ".count_up"

	var data []byte
	var err error
	if c.useJSON {
		data, err = protojson.Marshal(req)
	} else {
		data, err = proto.Marshal(req)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create inbox for receiving streamed responses
	inbox := nats.NewInbox()
	receiver, err := newClientStreamReceiver(c.nc, inbox, false)
	if err != nil {
		return nil, fmt.Errorf("failed to setup stream: %w", err)
	}

	// Send request with our inbox as Reply-To header
	msg := &nats.Msg{
		Subject: subject,
		Data:    data,
		Header:  nats.Header{},
	}
	msg.Header.Set("Reply-To", inbox)

	// Add outgoing headers from context
	if headers := OutgoingHeaders(ctx); headers != nil {
		for k, v := range headers {
			for _, val := range v {
				msg.Header.Add(k, val)
			}
		}
	}

	if err := c.nc.PublishMsg(msg); err != nil {
		receiver.Close()
		return nil, fmt.Errorf("failed to send streaming request: %w", err)
	}

	return &StreamDemoService_CountUp_ClientStream{
		receiver: receiver,
		useJSON:  c.useJSON,
	}, nil
}

// StreamDemoService_Sum_ClientStream is the client-side sender stream for Sum.
type StreamDemoService_Sum_ClientStream struct {
	nc      *nats.Conn
	sendTo  string // Server's inbox
	replyTo string // Our inbox for final response
	useJSON bool
	seq     int
	mu      sync.Mutex
}

// Send sends a message to the server.
func (s *StreamDemoService_Sum_ClientStream) Send(msg *SumRequest) error {
	var data []byte
	var err error
	if s.useJSON {
		data, err = protojson.Marshal(msg)
	} else {
		data, err = proto.Marshal(msg)
	}
	if err != nil {
		return fmt.Errorf("failed to marshal stream message: %w", err)
	}
	s.mu.Lock()
	s.seq++
	seq := s.seq
	s.mu.Unlock()
	m := &nats.Msg{
		Subject: s.sendTo,
		Data:    data,
		Header:  nats.Header{},
	}
	m.Header.Set(natsStreamSeqHeader, strconv.Itoa(seq))
	return s.nc.PublishMsg(m)
}

// CloseAndRecv signals end of client messages and waits for the server's response.
func (s *StreamDemoService_Sum_ClientStream) CloseAndRecv(ctx context.Context) (*SumResponse, error) {
	// Send end-of-stream marker
	m := &nats.Msg{
		Subject: s.sendTo,
		Header:  nats.Header{},
	}
	m.Header.Set(natsStreamEndHeader, "true")
	if err := s.nc.PublishMsg(m); err != nil {
		return nil, fmt.Errorf("failed to close send: %w", err)
	}

	// Wait for final response on our reply inbox
	sub, err := s.nc.SubscribeSync(s.replyTo)
	if err != nil {
		return nil, fmt.Errorf("failed to subscribe for response: %w", err)
	}
	defer sub.Unsubscribe()

	natsMsg, err := sub.NextMsgWithContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to receive response: %w", err)
	}

	var resp SumResponse
	if s.useJSON {
		if err := protojson.Unmarshal(natsMsg.Data, &resp); err != nil {
			return nil, fmt.Errorf("failed to decode response: %w", err)
		}
	} else {
		if err := proto.Unmarshal(natsMsg.Data, &resp); err != nil {
			return nil, fmt.Errorf("failed to decode response: %w", err)
		}
	}
	return &resp, nil
}

// Sum initiates a client-streaming RPC call.
func (c *StreamDemoServiceNatsClient) Sum(ctx context.Context) (*StreamDemoService_Sum_ClientStream, error) {
	subject := c.subjectPrefix + ".sum"

	// Create inbox for receiving the final response
	replyInbox := nats.NewInbox()

	// Send initial handshake to get server's inbox
	msg := &nats.Msg{
		Subject: subject,
		Header:  nats.Header{},
	}
	msg.Header.Set("Reply-To", replyInbox)

	ackMsg, err := c.nc.RequestMsgWithContext(ctx, msg)
	if err != nil {
		return nil, fmt.Errorf("failed to initiate client stream: %w", err)
	}

	serverInbox := ackMsg.Header.Get(natsStreamInboxHeader)
	if serverInbox == "" {
		return nil, fmt.Errorf("server did not provide stream inbox")
	}

	return &StreamDemoService_Sum_ClientStream{
		nc:      c.nc,
		sendTo:  serverInbox,
		replyTo: replyInbox,
		useJSON: c.useJSON,
	}, nil
}

// StreamDemoService_Chat_ClientStream is the client-side bidi stream for Chat.
type StreamDemoService_Chat_ClientStream struct {
	nc       *nats.Conn
	sendTo   string                // Server's inbox for sending messages
	receiver *ClientStreamReceiver // For receiving server messages
	useJSON  bool
	seq      int
	mu       sync.Mutex
}

// Send sends a message to the server.
func (s *StreamDemoService_Chat_ClientStream) Send(msg *ChatMessage) error {
	var data []byte
	var err error
	if s.useJSON {
		data, err = protojson.Marshal(msg)
	} else {
		data, err = proto.Marshal(msg)
	}
	if err != nil {
		return fmt.Errorf("failed to marshal stream message: %w", err)
	}
	s.mu.Lock()
	s.seq++
	seq := s.seq
	s.mu.Unlock()
	m := &nats.Msg{
		Subject: s.sendTo,
		Data:    data,
		Header:  nats.Header{},
	}
	m.Header.Set(natsStreamSeqHeader, strconv.Itoa(seq))
	return s.nc.PublishMsg(m)
}

// Recv blocks until the next response arrives from the server.
func (s *StreamDemoService_Chat_ClientStream) Recv(ctx context.Context) (*ChatMessage, error) {
	natsMsg, err := s.receiver.Recv(ctx)
	if err != nil {
		return nil, err
	}
	var resp ChatMessage
	if s.useJSON {
		if err := protojson.Unmarshal(natsMsg.Data, &resp); err != nil {
			return nil, fmt.Errorf("failed to decode stream message: %w", err)
		}
	} else {
		if err := proto.Unmarshal(natsMsg.Data, &resp); err != nil {
			return nil, fmt.Errorf("failed to decode stream message: %w", err)
		}
	}
	return &resp, nil
}

// CloseSend signals end of client messages.
func (s *StreamDemoService_Chat_ClientStream) CloseSend() error {
	m := &nats.Msg{
		Subject: s.sendTo,
		Header:  nats.Header{},
	}
	m.Header.Set(natsStreamEndHeader, "true")
	return s.nc.PublishMsg(m)
}

// Close unsubscribes from server messages.
func (s *StreamDemoService_Chat_ClientStream) Close() error {
	return s.receiver.Close()
}

// Chat initiates a bidirectional streaming RPC call.
func (c *StreamDemoServiceNatsClient) Chat(ctx context.Context) (*StreamDemoService_Chat_ClientStream, error) {
	subject := c.subjectPrefix + ".chat"

	// Create inbox for receiving server responses
	clientInbox := nats.NewInbox()
	receiver, err := newClientStreamReceiver(c.nc, clientInbox, false)
	if err != nil {
		return nil, fmt.Errorf("failed to setup stream: %w", err)
	}

	// Send initial handshake to get server's inbox
	msg := &nats.Msg{
		Subject: subject,
		Header:  nats.Header{},
	}
	msg.Header.Set("Reply-To", clientInbox)

	ackMsg, err := c.nc.RequestMsgWithContext(ctx, msg)
	if err != nil {
		receiver.Close()
		return nil, fmt.Errorf("failed to initiate bidi stream: %w", err)
	}

	serverInbox := ackMsg.Header.Get(natsStreamInboxHeader)
	if serverInbox == "" {
		receiver.Close()
		return nil, fmt.Errorf("server did not provide stream inbox")
	}

	return &StreamDemoService_Chat_ClientStream{
		nc:       c.nc,
		sendTo:   serverInbox,
		receiver: receiver,
		useJSON:  c.useJSON,
	}, nil
}

// Endpoints returns information about all service endpoints this client can call.
// This is useful for debugging, monitoring, and introspection.
func (c *StreamDemoServiceNatsClient) Endpoints() []StreamDemoServiceEndpointInfo {
	return []StreamDemoServiceEndpointInfo{
		{Name: "Ping", Subject: c.subjectPrefix + ".ping"},
		{Name: "CountUp", Subject: c.subjectPrefix + ".count_up"},
		{Name: "Sum", Subject: c.subjectPrefix + ".sum"},
		{Name: "Chat", Subject: c.subjectPrefix + ".chat"},
	}
}
