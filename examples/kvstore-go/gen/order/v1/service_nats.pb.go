// Code generated by protoc-gen-nats-micro. DO NOT EDIT.

package v1

import (
	"context"
	"errors"
	"fmt"
	"log"
	"os"
	"time"
	"github.com/nats-io/nats.go"
	"github.com/nats-io/nats.go/jetstream"
	"github.com/nats-io/nats.go/micro"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/encoding/protojson"
)

// OrderServiceError represents a structured error from OrderService
type OrderServiceError struct {
	Code    string // Error code (e.g., "INVALID_ARGUMENT", "NOT_FOUND", "INTERNAL")
	Message string // Human-readable error message
	Method  string // The method that failed
}

func (e *OrderServiceError) Error() string {
	return fmt.Sprintf("[%s] %s: %s", e.Code, e.Method, e.Message)
}

// NatsErrorCode returns the NATS error code for this error
func (e *OrderServiceError) NatsErrorCode() string {
	return e.Code
}

// NatsErrorMessage returns the NATS error message for this error
func (e *OrderServiceError) NatsErrorMessage() string {
	return e.Message
}

// NatsErrorData returns optional error data (nil for basic errors)
func (e *OrderServiceError) NatsErrorData() []byte {
	return nil
}

// Service-specific error code constants (use shared constants from service_shared_nats.pb.go)
const (
	OrderServiceErrCodeInvalidArgument  = ErrCodeInvalidArgument
	OrderServiceErrCodeNotFound         = ErrCodeNotFound
	OrderServiceErrCodeAlreadyExists    = ErrCodeAlreadyExists
	OrderServiceErrCodePermissionDenied = ErrCodePermissionDenied
	OrderServiceErrCodeUnauthenticated  = ErrCodeUnauthenticated
	OrderServiceErrCodeInternal         = ErrCodeInternal
	OrderServiceErrCodeUnavailable      = ErrCodeUnavailable
)

// IsOrderServiceInvalidArgument checks if the error is an invalid argument error
func IsOrderServiceInvalidArgument(err error) bool {
	var svcErr *OrderServiceError
	return errors.As(err, &svcErr) && svcErr.Code == OrderServiceErrCodeInvalidArgument
}

// IsOrderServiceNotFound checks if the error is a not found error
func IsOrderServiceNotFound(err error) bool {
	var svcErr *OrderServiceError
	return errors.As(err, &svcErr) && svcErr.Code == OrderServiceErrCodeNotFound
}

// IsOrderServiceAlreadyExists checks if the error is an already exists error
func IsOrderServiceAlreadyExists(err error) bool {
	var svcErr *OrderServiceError
	return errors.As(err, &svcErr) && svcErr.Code == OrderServiceErrCodeAlreadyExists
}

// IsOrderServicePermissionDenied checks if the error is a permission denied error
func IsOrderServicePermissionDenied(err error) bool {
	var svcErr *OrderServiceError
	return errors.As(err, &svcErr) && svcErr.Code == OrderServiceErrCodePermissionDenied
}

// IsOrderServiceUnauthenticated checks if the error is an unauthenticated error
func IsOrderServiceUnauthenticated(err error) bool {
	var svcErr *OrderServiceError
	return errors.As(err, &svcErr) && svcErr.Code == OrderServiceErrCodeUnauthenticated
}

// IsOrderServiceInternal checks if the error is an internal error
func IsOrderServiceInternal(err error) bool {
	var svcErr *OrderServiceError
	return errors.As(err, &svcErr) && svcErr.Code == OrderServiceErrCodeInternal
}

// IsOrderServiceUnavailable checks if the error is an unavailable error
func IsOrderServiceUnavailable(err error) bool {
	var svcErr *OrderServiceError
	return errors.As(err, &svcErr) && svcErr.Code == OrderServiceErrCodeUnavailable
}

// GetOrderServiceErrorCode extracts the error code from an error, returns empty string if not a OrderServiceError
func GetOrderServiceErrorCode(err error) string {
	var svcErr *OrderServiceError
	if errors.As(err, &svcErr) {
		return svcErr.Code
	}
	return ""
}

// NewOrderServiceInvalidArgumentError creates a new invalid argument error
func NewOrderServiceInvalidArgumentError(method, message string) error {
	return &OrderServiceError{Code: OrderServiceErrCodeInvalidArgument, Method: method, Message: message}
}

// NewOrderServiceNotFoundError creates a new not found error
func NewOrderServiceNotFoundError(method, message string) error {
	return &OrderServiceError{Code: OrderServiceErrCodeNotFound, Method: method, Message: message}
}

// NewOrderServiceAlreadyExistsError creates a new already exists error
func NewOrderServiceAlreadyExistsError(method, message string) error {
	return &OrderServiceError{Code: OrderServiceErrCodeAlreadyExists, Method: method, Message: message}
}

// NewOrderServicePermissionDeniedError creates a new permission denied error
func NewOrderServicePermissionDeniedError(method, message string) error {
	return &OrderServiceError{Code: OrderServiceErrCodePermissionDenied, Method: method, Message: message}
}

// NewOrderServiceUnauthenticatedError creates a new unauthenticated error
func NewOrderServiceUnauthenticatedError(method, message string) error {
	return &OrderServiceError{Code: OrderServiceErrCodeUnauthenticated, Method: method, Message: message}
}

// NewOrderServiceInternalError creates a new internal error
func NewOrderServiceInternalError(method, message string) error {
	return &OrderServiceError{Code: OrderServiceErrCodeInternal, Method: method, Message: message}
}

// NewOrderServiceUnavailableError creates a new unavailable error
func NewOrderServiceUnavailableError(method, message string) error {
	return &OrderServiceError{Code: OrderServiceErrCodeUnavailable, Method: method, Message: message}
}

// OrderServiceNats is the NATS service interface for OrderService
type OrderServiceNats interface {
	CreateOrder(context.Context, *CreateOrderRequest) (*CreateOrderResponse, error)
	GetOrder(context.Context, *GetOrderRequest) (*GetOrderResponse, error)
	ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error)
	UpdateOrderStatus(context.Context, *UpdateOrderStatusRequest) (*UpdateOrderStatusResponse, error)
}

// OrderServiceEndpointInfo describes a service endpoint
type OrderServiceEndpointInfo struct {
	Name    string `json:"name"`    // Method name (e.g., "CreateProduct")
	Subject string `json:"subject"` // NATS subject (e.g., "api.v1.create_product")
}

// OrderServiceService is the interface for the registered NATS micro service
// This interface allows for easier dependency injection and testing
type OrderServiceService interface {
	micro.Service
	Endpoints() []OrderServiceEndpointInfo
}

// orderServiceService is the concrete implementation of OrderServiceService
type orderServiceService struct {
	micro.Service
	subjectPrefix string
}

// Endpoints returns information about all service endpoints
// This is useful for debugging, monitoring, and service discovery
func (s *orderServiceService) Endpoints() []OrderServiceEndpointInfo {
	return []OrderServiceEndpointInfo{
		{Name: "CreateOrder", Subject: s.subjectPrefix + ".create_order"},
		{Name: "GetOrder", Subject: s.subjectPrefix + ".get_order"},
		{Name: "ListOrders", Subject: s.subjectPrefix + ".list_orders"},
		{Name: "UpdateOrderStatus", Subject: s.subjectPrefix + ".update_order_status"},
	}
}

// RegisterOrderServiceHandlers registers the service with NATS micro handlers
// Service: order_service v1.0.0
// Description: Order management service v1
// Subject prefix: api.v1
// Configuration options: WithName(), WithVersion(), WithDescription(), WithSubjectPrefix(), WithTimeout()
// Metadata options: WithMetadata() (replace), WithAdditionalMetadata() (merge)
// Handler options: WithStatsHandler(), WithDoneHandler(), WithErrorHandler()
//
// Endpoint metadata can be configured via proto options (nats.micro.endpoint).metadata
func RegisterOrderServiceHandlers(nc *nats.Conn, impl OrderServiceNats, opts ...RegisterOption) (OrderServiceService, error) {
	cfg := &registerConfig{
		name:          "order_service",
		version:       "1.0.0",
		description:   "Order management service v1",
		subjectPrefix: "api.v1",
		timeout:       0 * time.Second, // Service-level timeout (0 = no timeout)
		metadata:      map[string]string{},
	}
	for _, opt := range opts {
		opt(cfg)
	}

	svc, err := micro.AddService(nc, micro.Config{
		Name:         cfg.name,
		Version:      cfg.version,
		Metadata:     cfg.metadata,
		Description:  cfg.description,
		StatsHandler: cfg.statsHandler,
		DoneHandler:  cfg.doneHandler,
		ErrorHandler: cfg.errorHandler,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to add service: %w", err)
	}

	// Chain server interceptors
	var chainedInterceptor UnaryServerInterceptor
	if len(cfg.serverInterceptors) > 0 {
		chainedInterceptor = chainUnaryServerInterceptors(cfg.serverInterceptors)
	}

	handlers := &orderServiceHandlers{
		impl:           impl,
		serviceTimeout: cfg.timeout,
		useJSON:        false,
		interceptor:    chainedInterceptor,
		js:             cfg.js,
	}

	// Map of endpoint names to their handlers
	endpoints := map[string]micro.Handler{

		"create_order": micro.HandlerFunc(handlers.CreateOrder),

		"get_order": micro.HandlerFunc(handlers.GetOrder),

		"list_orders": micro.HandlerFunc(handlers.ListOrders),

		"update_order_status": micro.HandlerFunc(handlers.UpdateOrderStatus),
	}

	// Map of endpoint names to their metadata
	endpointMetadata := map[string]map[string]string{

		"create_order": {},

		"get_order": {},

		"list_orders": {},

		"update_order_status": {},
	}

	// Use interface to handle both Service and Group
	type endpointAdder interface {
		AddEndpoint(string, micro.Handler, ...micro.EndpointOpt) error
	}

	var adder endpointAdder = svc
	if cfg.subjectPrefix != "" {
		adder = svc.AddGroup(cfg.subjectPrefix)
	}

	// Register all endpoints with their metadata
	for name, handler := range endpoints {
		opts := []micro.EndpointOpt{}
		if metadata, exists := endpointMetadata[name]; exists && len(metadata) > 0 {
			opts = append(opts, micro.WithEndpointMetadata(metadata))
		}
		if err := adder.AddEndpoint(name, handler, opts...); err != nil {
			return nil, fmt.Errorf("failed to add endpoint %s: %w", name, err)
		}
	}

	return &orderServiceService{
		Service:       svc,
		subjectPrefix: cfg.subjectPrefix,
	}, nil
}

// orderServiceHandlers wraps the service implementation with NATS handlers
type orderServiceHandlers struct {
	impl           OrderServiceNats
	serviceTimeout time.Duration          // Default timeout for all endpoints
	useJSON        bool                   // Use JSON encoding instead of binary protobuf
	interceptor    UnaryServerInterceptor // Chained interceptors
	js             jetstream.JetStream    // Optional JetStream context for KV/ObjectStore
}

func (h *orderServiceHandlers) CreateOrder(req micro.Request) {
	// Determine effective timeout: endpoint-specific timeout overrides service timeout
	// If endpoint timeout is set (> 0), use it; otherwise use service timeout
	timeout := h.serviceTimeout

	// Create context with timeout if configured, otherwise use background context
	ctx := context.Background()
	var cancel context.CancelFunc
	if timeout > 0 {
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}

	// Add incoming NATS headers to context so service methods can access them
	if req.Headers() != nil {
		ctx = WithIncomingHeaders(ctx, req.Headers())
	}

	// Initialize outgoing headers pointer in context so interceptors can set response headers
	outgoingHeadersPtr := &nats.Header{}
	ctx = context.WithValue(ctx, outgoingHeadersKey, outgoingHeadersPtr)

	var msg CreateOrderRequest
	if h.useJSON {
		if err := protojson.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(OrderServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode JSON request: %v", err), nil)
			return
		}
	} else {
		if err := proto.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(OrderServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode request: %v", err), nil)
			return
		}
	}

	// Define the handler function
	handler := func(ctx context.Context, request interface{}) (interface{}, error) {
		typedReq, ok := request.(*CreateOrderRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type")
		}
		return h.impl.CreateOrder(ctx, typedReq)
	}

	// Execute through interceptor chain if configured
	var resp interface{}
	var err error
	if h.interceptor != nil {
		info := &UnaryServerInfo{
			Service: "OrderService",
			Method:  "CreateOrder",
			Subject: "api.v1.create_order",
		}
		resp, err = h.interceptor(ctx, &msg, info, handler)
	} else {
		resp, err = handler(ctx, &msg)
	}
	if err != nil {
		// Check if error implements custom status code/message/data methods
		code := OrderServiceErrCodeInternal
		message := err.Error()
		var data []byte

		// Check for NatsErrorCode() string method
		if coder, ok := err.(interface{ NatsErrorCode() string }); ok {
			code = coder.NatsErrorCode()
		}
		// Check for NatsErrorMessage() string method
		if messager, ok := err.(interface{ NatsErrorMessage() string }); ok {
			message = messager.NatsErrorMessage()
		}
		// Check for NatsErrorData() []byte method
		if dataProvider, ok := err.(interface{ NatsErrorData() []byte }); ok {
			data = dataProvider.NatsErrorData()
		}

		req.Error(code, message, data)
		return
	}

	// Type assert response back to the expected type
	typedResp, ok := resp.(*CreateOrderResponse)
	if !ok {
		req.Error(OrderServiceErrCodeInternal, "invalid response type from handler", nil)
		return
	}

	var data []byte
	if h.useJSON {
		data, err = protojson.Marshal(typedResp)
		if err != nil {
			req.Error(OrderServiceErrCodeInternal, fmt.Sprintf("failed to encode JSON response: %v", err), nil)
			return
		}
	} else {
		data, err = proto.Marshal(typedResp)
		if err != nil {
			req.Error(OrderServiceErrCodeInternal, fmt.Sprintf("failed to encode response: %v", err), nil)
			return
		}
	}

	// Check if context has outgoing headers set by interceptors
	// Read from the pointer that was initialized at the start
	var outgoingHeaders nats.Header
	if headersPtr, ok := ctx.Value(outgoingHeadersKey).(*nats.Header); ok && headersPtr != nil {
		outgoingHeaders = *headersPtr
	}

	if len(outgoingHeaders) > 0 {
		// Send response with headers using micro.WithHeaders
		// Convert nats.Header to micro.Headers (they are the same underlying type)
		if err := req.Respond(data, micro.WithHeaders(micro.Headers(outgoingHeaders))); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for CreateOrder: %v\n", err)
		}
	} else {
		// Send response without headers
		if err := req.Respond(data); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for CreateOrder: %v\n", err)
		}
	}
}

func (h *orderServiceHandlers) GetOrder(req micro.Request) {
	// Determine effective timeout: endpoint-specific timeout overrides service timeout
	// If endpoint timeout is set (> 0), use it; otherwise use service timeout
	timeout := h.serviceTimeout

	// Create context with timeout if configured, otherwise use background context
	ctx := context.Background()
	var cancel context.CancelFunc
	if timeout > 0 {
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}

	// Add incoming NATS headers to context so service methods can access them
	if req.Headers() != nil {
		ctx = WithIncomingHeaders(ctx, req.Headers())
	}

	// Initialize outgoing headers pointer in context so interceptors can set response headers
	outgoingHeadersPtr := &nats.Header{}
	ctx = context.WithValue(ctx, outgoingHeadersKey, outgoingHeadersPtr)

	var msg GetOrderRequest
	if h.useJSON {
		if err := protojson.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(OrderServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode JSON request: %v", err), nil)
			return
		}
	} else {
		if err := proto.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(OrderServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode request: %v", err), nil)
			return
		}
	}

	// Define the handler function
	handler := func(ctx context.Context, request interface{}) (interface{}, error) {
		typedReq, ok := request.(*GetOrderRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type")
		}
		return h.impl.GetOrder(ctx, typedReq)
	}

	// Execute through interceptor chain if configured
	var resp interface{}
	var err error
	if h.interceptor != nil {
		info := &UnaryServerInfo{
			Service: "OrderService",
			Method:  "GetOrder",
			Subject: "api.v1.get_order",
		}
		resp, err = h.interceptor(ctx, &msg, info, handler)
	} else {
		resp, err = handler(ctx, &msg)
	}
	if err != nil {
		// Check if error implements custom status code/message/data methods
		code := OrderServiceErrCodeInternal
		message := err.Error()
		var data []byte

		// Check for NatsErrorCode() string method
		if coder, ok := err.(interface{ NatsErrorCode() string }); ok {
			code = coder.NatsErrorCode()
		}
		// Check for NatsErrorMessage() string method
		if messager, ok := err.(interface{ NatsErrorMessage() string }); ok {
			message = messager.NatsErrorMessage()
		}
		// Check for NatsErrorData() []byte method
		if dataProvider, ok := err.(interface{ NatsErrorData() []byte }); ok {
			data = dataProvider.NatsErrorData()
		}

		req.Error(code, message, data)
		return
	}

	// Type assert response back to the expected type
	typedResp, ok := resp.(*GetOrderResponse)
	if !ok {
		req.Error(OrderServiceErrCodeInternal, "invalid response type from handler", nil)
		return
	}

	var data []byte
	if h.useJSON {
		data, err = protojson.Marshal(typedResp)
		if err != nil {
			req.Error(OrderServiceErrCodeInternal, fmt.Sprintf("failed to encode JSON response: %v", err), nil)
			return
		}
	} else {
		data, err = proto.Marshal(typedResp)
		if err != nil {
			req.Error(OrderServiceErrCodeInternal, fmt.Sprintf("failed to encode response: %v", err), nil)
			return
		}
	}

	// Check if context has outgoing headers set by interceptors
	// Read from the pointer that was initialized at the start
	var outgoingHeaders nats.Header
	if headersPtr, ok := ctx.Value(outgoingHeadersKey).(*nats.Header); ok && headersPtr != nil {
		outgoingHeaders = *headersPtr
	}

	if len(outgoingHeaders) > 0 {
		// Send response with headers using micro.WithHeaders
		// Convert nats.Header to micro.Headers (they are the same underlying type)
		if err := req.Respond(data, micro.WithHeaders(micro.Headers(outgoingHeaders))); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for GetOrder: %v\n", err)
		}
	} else {
		// Send response without headers
		if err := req.Respond(data); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for GetOrder: %v\n", err)
		}
	}
}

func (h *orderServiceHandlers) ListOrders(req micro.Request) {
	// Determine effective timeout: endpoint-specific timeout overrides service timeout
	// If endpoint timeout is set (> 0), use it; otherwise use service timeout
	timeout := h.serviceTimeout

	// Create context with timeout if configured, otherwise use background context
	ctx := context.Background()
	var cancel context.CancelFunc
	if timeout > 0 {
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}

	// Add incoming NATS headers to context so service methods can access them
	if req.Headers() != nil {
		ctx = WithIncomingHeaders(ctx, req.Headers())
	}

	// Initialize outgoing headers pointer in context so interceptors can set response headers
	outgoingHeadersPtr := &nats.Header{}
	ctx = context.WithValue(ctx, outgoingHeadersKey, outgoingHeadersPtr)

	var msg ListOrdersRequest
	if h.useJSON {
		if err := protojson.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(OrderServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode JSON request: %v", err), nil)
			return
		}
	} else {
		if err := proto.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(OrderServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode request: %v", err), nil)
			return
		}
	}

	// Define the handler function
	handler := func(ctx context.Context, request interface{}) (interface{}, error) {
		typedReq, ok := request.(*ListOrdersRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type")
		}
		return h.impl.ListOrders(ctx, typedReq)
	}

	// Execute through interceptor chain if configured
	var resp interface{}
	var err error
	if h.interceptor != nil {
		info := &UnaryServerInfo{
			Service: "OrderService",
			Method:  "ListOrders",
			Subject: "api.v1.list_orders",
		}
		resp, err = h.interceptor(ctx, &msg, info, handler)
	} else {
		resp, err = handler(ctx, &msg)
	}
	if err != nil {
		// Check if error implements custom status code/message/data methods
		code := OrderServiceErrCodeInternal
		message := err.Error()
		var data []byte

		// Check for NatsErrorCode() string method
		if coder, ok := err.(interface{ NatsErrorCode() string }); ok {
			code = coder.NatsErrorCode()
		}
		// Check for NatsErrorMessage() string method
		if messager, ok := err.(interface{ NatsErrorMessage() string }); ok {
			message = messager.NatsErrorMessage()
		}
		// Check for NatsErrorData() []byte method
		if dataProvider, ok := err.(interface{ NatsErrorData() []byte }); ok {
			data = dataProvider.NatsErrorData()
		}

		req.Error(code, message, data)
		return
	}

	// Type assert response back to the expected type
	typedResp, ok := resp.(*ListOrdersResponse)
	if !ok {
		req.Error(OrderServiceErrCodeInternal, "invalid response type from handler", nil)
		return
	}

	var data []byte
	if h.useJSON {
		data, err = protojson.Marshal(typedResp)
		if err != nil {
			req.Error(OrderServiceErrCodeInternal, fmt.Sprintf("failed to encode JSON response: %v", err), nil)
			return
		}
	} else {
		data, err = proto.Marshal(typedResp)
		if err != nil {
			req.Error(OrderServiceErrCodeInternal, fmt.Sprintf("failed to encode response: %v", err), nil)
			return
		}
	}

	// Check if context has outgoing headers set by interceptors
	// Read from the pointer that was initialized at the start
	var outgoingHeaders nats.Header
	if headersPtr, ok := ctx.Value(outgoingHeadersKey).(*nats.Header); ok && headersPtr != nil {
		outgoingHeaders = *headersPtr
	}

	if len(outgoingHeaders) > 0 {
		// Send response with headers using micro.WithHeaders
		// Convert nats.Header to micro.Headers (they are the same underlying type)
		if err := req.Respond(data, micro.WithHeaders(micro.Headers(outgoingHeaders))); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for ListOrders: %v\n", err)
		}
	} else {
		// Send response without headers
		if err := req.Respond(data); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for ListOrders: %v\n", err)
		}
	}
}

func (h *orderServiceHandlers) UpdateOrderStatus(req micro.Request) {
	// Determine effective timeout: endpoint-specific timeout overrides service timeout
	// If endpoint timeout is set (> 0), use it; otherwise use service timeout
	timeout := h.serviceTimeout

	// Create context with timeout if configured, otherwise use background context
	ctx := context.Background()
	var cancel context.CancelFunc
	if timeout > 0 {
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}

	// Add incoming NATS headers to context so service methods can access them
	if req.Headers() != nil {
		ctx = WithIncomingHeaders(ctx, req.Headers())
	}

	// Initialize outgoing headers pointer in context so interceptors can set response headers
	outgoingHeadersPtr := &nats.Header{}
	ctx = context.WithValue(ctx, outgoingHeadersKey, outgoingHeadersPtr)

	var msg UpdateOrderStatusRequest
	if h.useJSON {
		if err := protojson.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(OrderServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode JSON request: %v", err), nil)
			return
		}
	} else {
		if err := proto.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(OrderServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode request: %v", err), nil)
			return
		}
	}

	// Define the handler function
	handler := func(ctx context.Context, request interface{}) (interface{}, error) {
		typedReq, ok := request.(*UpdateOrderStatusRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type")
		}
		return h.impl.UpdateOrderStatus(ctx, typedReq)
	}

	// Execute through interceptor chain if configured
	var resp interface{}
	var err error
	if h.interceptor != nil {
		info := &UnaryServerInfo{
			Service: "OrderService",
			Method:  "UpdateOrderStatus",
			Subject: "api.v1.update_order_status",
		}
		resp, err = h.interceptor(ctx, &msg, info, handler)
	} else {
		resp, err = handler(ctx, &msg)
	}
	if err != nil {
		// Check if error implements custom status code/message/data methods
		code := OrderServiceErrCodeInternal
		message := err.Error()
		var data []byte

		// Check for NatsErrorCode() string method
		if coder, ok := err.(interface{ NatsErrorCode() string }); ok {
			code = coder.NatsErrorCode()
		}
		// Check for NatsErrorMessage() string method
		if messager, ok := err.(interface{ NatsErrorMessage() string }); ok {
			message = messager.NatsErrorMessage()
		}
		// Check for NatsErrorData() []byte method
		if dataProvider, ok := err.(interface{ NatsErrorData() []byte }); ok {
			data = dataProvider.NatsErrorData()
		}

		req.Error(code, message, data)
		return
	}

	// Type assert response back to the expected type
	typedResp, ok := resp.(*UpdateOrderStatusResponse)
	if !ok {
		req.Error(OrderServiceErrCodeInternal, "invalid response type from handler", nil)
		return
	}

	var data []byte
	if h.useJSON {
		data, err = protojson.Marshal(typedResp)
		if err != nil {
			req.Error(OrderServiceErrCodeInternal, fmt.Sprintf("failed to encode JSON response: %v", err), nil)
			return
		}
	} else {
		data, err = proto.Marshal(typedResp)
		if err != nil {
			req.Error(OrderServiceErrCodeInternal, fmt.Sprintf("failed to encode response: %v", err), nil)
			return
		}
	}

	// Check if context has outgoing headers set by interceptors
	// Read from the pointer that was initialized at the start
	var outgoingHeaders nats.Header
	if headersPtr, ok := ctx.Value(outgoingHeadersKey).(*nats.Header); ok && headersPtr != nil {
		outgoingHeaders = *headersPtr
	}

	if len(outgoingHeaders) > 0 {
		// Send response with headers using micro.WithHeaders
		// Convert nats.Header to micro.Headers (they are the same underlying type)
		if err := req.Respond(data, micro.WithHeaders(micro.Headers(outgoingHeaders))); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for UpdateOrderStatus: %v\n", err)
		}
	} else {
		// Send response without headers
		if err := req.Respond(data); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for UpdateOrderStatus: %v\n", err)
		}
	}
}

// OrderServiceNatsClientInterface is the interface for the NATS client
// This interface allows for easier dependency injection and testing
type OrderServiceNatsClientInterface interface {
	CreateOrder(context.Context, *CreateOrderRequest) (*CreateOrderResponse, error)
	GetOrder(context.Context, *GetOrderRequest) (*GetOrderResponse, error)
	ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error)
	UpdateOrderStatus(context.Context, *UpdateOrderStatusRequest) (*UpdateOrderStatusResponse, error)
	Endpoints() []OrderServiceEndpointInfo
}

// OrderServiceNatsClient is the concrete implementation of OrderServiceNatsClientInterface
type OrderServiceNatsClient struct {
	nc            *nats.Conn
	subjectPrefix string
	useJSON       bool                   // Use JSON encoding instead of binary protobuf
	interceptor   UnaryClientInterceptor // Chained interceptors
	js            jetstream.JetStream    // Optional JetStream for KV/ObjectStore reads
}

// NewOrderServiceNatsClient creates a new NATS client for OrderService.
// The client sends requests over NATS using protobuf serialization (or JSON if configured).
func NewOrderServiceNatsClient(nc *nats.Conn, opts ...NatsClientOption) OrderServiceNatsClientInterface {
	cfg := &natsClientConfig{
		subjectPrefix: "api.v1",
	}
	for _, opt := range opts {
		opt.applyNatsClientOption(cfg)
	}

	// Chain client interceptors
	var chainedInterceptor UnaryClientInterceptor
	if len(cfg.clientInterceptors) > 0 {
		chainedInterceptor = chainUnaryClientInterceptors(cfg.clientInterceptors)
	}

	c := &OrderServiceNatsClient{
		nc:            nc,
		subjectPrefix: cfg.subjectPrefix,
		useJSON:       false,
		interceptor:   chainedInterceptor,
		js:            cfg.js,
	}
	return c
}

// CreateOrder sends a CreateOrder request to the service via NATS.
// Returns an error if the request fails or the service returns an error.
func (c *OrderServiceNatsClient) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*CreateOrderResponse, error) {
	method := "CreateOrder"

	// Pointer to store response headers - stored in context so invoker can update it
	responseHeadersPtr := &nats.Header{}

	// Add the response headers pointer to context so invoker can populate it
	// Interceptors can then read the headers from the same context
	ctx = context.WithValue(ctx, responseHeadersKey, responseHeadersPtr)

	// Define the invoker function that performs the actual NATS call
	invoker := func(invokerCtx context.Context, method string, request, reply interface{}) error {
		subject := c.subjectPrefix + ".create_order"

		// Marshal request
		typedReq, ok := request.(*CreateOrderRequest)
		if !ok {
			return fmt.Errorf("invalid request type")
		}

		var data []byte
		var err error
		if c.useJSON {
			data, err = protojson.Marshal(typedReq)
		} else {
			data, err = proto.Marshal(typedReq)
		}
		if err != nil {
			return err
		}

		// Extract outgoing headers from context and attach to NATS message
		var msg *nats.Msg
		if headers := OutgoingHeaders(invokerCtx); headers != nil {
			msg, err = c.nc.RequestMsgWithContext(invokerCtx, &nats.Msg{
				Subject: subject,
				Data:    data,
				Header:  headers,
			})
		} else {
			msg, err = c.nc.RequestWithContext(invokerCtx, subject, data)
		}
		if err != nil {
			return err
		}

		// Store response headers in the pointer from context
		if msg.Header != nil && len(msg.Header) > 0 {
			if headersPtr, ok := invokerCtx.Value(responseHeadersKey).(*nats.Header); ok && headersPtr != nil {
				*headersPtr = msg.Header
			}
		} // Check if this is an error response from the service
		if msg.Header.Get("Status") != "" {
			code := msg.Header.Get("Status")
			description := msg.Header.Get("Description")
			return &OrderServiceError{
				Code:    code,
				Method:  method,
				Message: description,
			}
		}

		// Unmarshal response
		typedReply, ok := reply.(*CreateOrderResponse)
		if !ok {
			return fmt.Errorf("invalid reply type")
		}

		if c.useJSON {
			err = protojson.Unmarshal(msg.Data, typedReply)
		} else {
			err = proto.Unmarshal(msg.Data, typedReply)
		}
		return err
	}

	var resp CreateOrderResponse

	// Execute through interceptor chain if configured
	var err error
	if c.interceptor != nil {
		err = c.interceptor(ctx, method, req, &resp, invoker)
	} else {
		err = invoker(ctx, method, req, &resp)
	}

	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// GetOrder sends a GetOrder request to the service via NATS.
// Returns an error if the request fails or the service returns an error.
func (c *OrderServiceNatsClient) GetOrder(ctx context.Context, req *GetOrderRequest) (*GetOrderResponse, error) {
	method := "GetOrder"

	// Pointer to store response headers - stored in context so invoker can update it
	responseHeadersPtr := &nats.Header{}

	// Add the response headers pointer to context so invoker can populate it
	// Interceptors can then read the headers from the same context
	ctx = context.WithValue(ctx, responseHeadersKey, responseHeadersPtr)

	// Define the invoker function that performs the actual NATS call
	invoker := func(invokerCtx context.Context, method string, request, reply interface{}) error {
		subject := c.subjectPrefix + ".get_order"

		// Marshal request
		typedReq, ok := request.(*GetOrderRequest)
		if !ok {
			return fmt.Errorf("invalid request type")
		}

		var data []byte
		var err error
		if c.useJSON {
			data, err = protojson.Marshal(typedReq)
		} else {
			data, err = proto.Marshal(typedReq)
		}
		if err != nil {
			return err
		}

		// Extract outgoing headers from context and attach to NATS message
		var msg *nats.Msg
		if headers := OutgoingHeaders(invokerCtx); headers != nil {
			msg, err = c.nc.RequestMsgWithContext(invokerCtx, &nats.Msg{
				Subject: subject,
				Data:    data,
				Header:  headers,
			})
		} else {
			msg, err = c.nc.RequestWithContext(invokerCtx, subject, data)
		}
		if err != nil {
			return err
		}

		// Store response headers in the pointer from context
		if msg.Header != nil && len(msg.Header) > 0 {
			if headersPtr, ok := invokerCtx.Value(responseHeadersKey).(*nats.Header); ok && headersPtr != nil {
				*headersPtr = msg.Header
			}
		} // Check if this is an error response from the service
		if msg.Header.Get("Status") != "" {
			code := msg.Header.Get("Status")
			description := msg.Header.Get("Description")
			return &OrderServiceError{
				Code:    code,
				Method:  method,
				Message: description,
			}
		}

		// Unmarshal response
		typedReply, ok := reply.(*GetOrderResponse)
		if !ok {
			return fmt.Errorf("invalid reply type")
		}

		if c.useJSON {
			err = protojson.Unmarshal(msg.Data, typedReply)
		} else {
			err = proto.Unmarshal(msg.Data, typedReply)
		}
		return err
	}

	var resp GetOrderResponse

	// Execute through interceptor chain if configured
	var err error
	if c.interceptor != nil {
		err = c.interceptor(ctx, method, req, &resp, invoker)
	} else {
		err = invoker(ctx, method, req, &resp)
	}

	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// ListOrders sends a ListOrders request to the service via NATS.
// Returns an error if the request fails or the service returns an error.
func (c *OrderServiceNatsClient) ListOrders(ctx context.Context, req *ListOrdersRequest) (*ListOrdersResponse, error) {
	method := "ListOrders"

	// Pointer to store response headers - stored in context so invoker can update it
	responseHeadersPtr := &nats.Header{}

	// Add the response headers pointer to context so invoker can populate it
	// Interceptors can then read the headers from the same context
	ctx = context.WithValue(ctx, responseHeadersKey, responseHeadersPtr)

	// Define the invoker function that performs the actual NATS call
	invoker := func(invokerCtx context.Context, method string, request, reply interface{}) error {
		subject := c.subjectPrefix + ".list_orders"

		// Marshal request
		typedReq, ok := request.(*ListOrdersRequest)
		if !ok {
			return fmt.Errorf("invalid request type")
		}

		var data []byte
		var err error
		if c.useJSON {
			data, err = protojson.Marshal(typedReq)
		} else {
			data, err = proto.Marshal(typedReq)
		}
		if err != nil {
			return err
		}

		// Extract outgoing headers from context and attach to NATS message
		var msg *nats.Msg
		if headers := OutgoingHeaders(invokerCtx); headers != nil {
			msg, err = c.nc.RequestMsgWithContext(invokerCtx, &nats.Msg{
				Subject: subject,
				Data:    data,
				Header:  headers,
			})
		} else {
			msg, err = c.nc.RequestWithContext(invokerCtx, subject, data)
		}
		if err != nil {
			return err
		}

		// Store response headers in the pointer from context
		if msg.Header != nil && len(msg.Header) > 0 {
			if headersPtr, ok := invokerCtx.Value(responseHeadersKey).(*nats.Header); ok && headersPtr != nil {
				*headersPtr = msg.Header
			}
		} // Check if this is an error response from the service
		if msg.Header.Get("Status") != "" {
			code := msg.Header.Get("Status")
			description := msg.Header.Get("Description")
			return &OrderServiceError{
				Code:    code,
				Method:  method,
				Message: description,
			}
		}

		// Unmarshal response
		typedReply, ok := reply.(*ListOrdersResponse)
		if !ok {
			return fmt.Errorf("invalid reply type")
		}

		if c.useJSON {
			err = protojson.Unmarshal(msg.Data, typedReply)
		} else {
			err = proto.Unmarshal(msg.Data, typedReply)
		}
		return err
	}

	var resp ListOrdersResponse

	// Execute through interceptor chain if configured
	var err error
	if c.interceptor != nil {
		err = c.interceptor(ctx, method, req, &resp, invoker)
	} else {
		err = invoker(ctx, method, req, &resp)
	}

	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// UpdateOrderStatus sends a UpdateOrderStatus request to the service via NATS.
// Returns an error if the request fails or the service returns an error.
func (c *OrderServiceNatsClient) UpdateOrderStatus(ctx context.Context, req *UpdateOrderStatusRequest) (*UpdateOrderStatusResponse, error) {
	method := "UpdateOrderStatus"

	// Pointer to store response headers - stored in context so invoker can update it
	responseHeadersPtr := &nats.Header{}

	// Add the response headers pointer to context so invoker can populate it
	// Interceptors can then read the headers from the same context
	ctx = context.WithValue(ctx, responseHeadersKey, responseHeadersPtr)

	// Define the invoker function that performs the actual NATS call
	invoker := func(invokerCtx context.Context, method string, request, reply interface{}) error {
		subject := c.subjectPrefix + ".update_order_status"

		// Marshal request
		typedReq, ok := request.(*UpdateOrderStatusRequest)
		if !ok {
			return fmt.Errorf("invalid request type")
		}

		var data []byte
		var err error
		if c.useJSON {
			data, err = protojson.Marshal(typedReq)
		} else {
			data, err = proto.Marshal(typedReq)
		}
		if err != nil {
			return err
		}

		// Extract outgoing headers from context and attach to NATS message
		var msg *nats.Msg
		if headers := OutgoingHeaders(invokerCtx); headers != nil {
			msg, err = c.nc.RequestMsgWithContext(invokerCtx, &nats.Msg{
				Subject: subject,
				Data:    data,
				Header:  headers,
			})
		} else {
			msg, err = c.nc.RequestWithContext(invokerCtx, subject, data)
		}
		if err != nil {
			return err
		}

		// Store response headers in the pointer from context
		if msg.Header != nil && len(msg.Header) > 0 {
			if headersPtr, ok := invokerCtx.Value(responseHeadersKey).(*nats.Header); ok && headersPtr != nil {
				*headersPtr = msg.Header
			}
		} // Check if this is an error response from the service
		if msg.Header.Get("Status") != "" {
			code := msg.Header.Get("Status")
			description := msg.Header.Get("Description")
			return &OrderServiceError{
				Code:    code,
				Method:  method,
				Message: description,
			}
		}

		// Unmarshal response
		typedReply, ok := reply.(*UpdateOrderStatusResponse)
		if !ok {
			return fmt.Errorf("invalid reply type")
		}

		if c.useJSON {
			err = protojson.Unmarshal(msg.Data, typedReply)
		} else {
			err = proto.Unmarshal(msg.Data, typedReply)
		}
		return err
	}

	var resp UpdateOrderStatusResponse

	// Execute through interceptor chain if configured
	var err error
	if c.interceptor != nil {
		err = c.interceptor(ctx, method, req, &resp, invoker)
	} else {
		err = invoker(ctx, method, req, &resp)
	}

	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// Endpoints returns information about all service endpoints this client can call.
// This is useful for debugging, monitoring, and introspection.
func (c *OrderServiceNatsClient) Endpoints() []OrderServiceEndpointInfo {
	return []OrderServiceEndpointInfo{
		{Name: "CreateOrder", Subject: c.subjectPrefix + ".create_order"},
		{Name: "GetOrder", Subject: c.subjectPrefix + ".get_order"},
		{Name: "ListOrders", Subject: c.subjectPrefix + ".list_orders"},
		{Name: "UpdateOrderStatus", Subject: c.subjectPrefix + ".update_order_status"},
	}
}

// OrderTrackingServiceError represents a structured error from OrderTrackingService
type OrderTrackingServiceError struct {
	Code    string // Error code (e.g., "INVALID_ARGUMENT", "NOT_FOUND", "INTERNAL")
	Message string // Human-readable error message
	Method  string // The method that failed
}

func (e *OrderTrackingServiceError) Error() string {
	return fmt.Sprintf("[%s] %s: %s", e.Code, e.Method, e.Message)
}

// NatsErrorCode returns the NATS error code for this error
func (e *OrderTrackingServiceError) NatsErrorCode() string {
	return e.Code
}

// NatsErrorMessage returns the NATS error message for this error
func (e *OrderTrackingServiceError) NatsErrorMessage() string {
	return e.Message
}

// NatsErrorData returns optional error data (nil for basic errors)
func (e *OrderTrackingServiceError) NatsErrorData() []byte {
	return nil
}

// Service-specific error code constants (use shared constants from service_shared_nats.pb.go)
const (
	OrderTrackingServiceErrCodeInvalidArgument  = ErrCodeInvalidArgument
	OrderTrackingServiceErrCodeNotFound         = ErrCodeNotFound
	OrderTrackingServiceErrCodeAlreadyExists    = ErrCodeAlreadyExists
	OrderTrackingServiceErrCodePermissionDenied = ErrCodePermissionDenied
	OrderTrackingServiceErrCodeUnauthenticated  = ErrCodeUnauthenticated
	OrderTrackingServiceErrCodeInternal         = ErrCodeInternal
	OrderTrackingServiceErrCodeUnavailable      = ErrCodeUnavailable
)

// IsOrderTrackingServiceInvalidArgument checks if the error is an invalid argument error
func IsOrderTrackingServiceInvalidArgument(err error) bool {
	var svcErr *OrderTrackingServiceError
	return errors.As(err, &svcErr) && svcErr.Code == OrderTrackingServiceErrCodeInvalidArgument
}

// IsOrderTrackingServiceNotFound checks if the error is a not found error
func IsOrderTrackingServiceNotFound(err error) bool {
	var svcErr *OrderTrackingServiceError
	return errors.As(err, &svcErr) && svcErr.Code == OrderTrackingServiceErrCodeNotFound
}

// IsOrderTrackingServiceAlreadyExists checks if the error is an already exists error
func IsOrderTrackingServiceAlreadyExists(err error) bool {
	var svcErr *OrderTrackingServiceError
	return errors.As(err, &svcErr) && svcErr.Code == OrderTrackingServiceErrCodeAlreadyExists
}

// IsOrderTrackingServicePermissionDenied checks if the error is a permission denied error
func IsOrderTrackingServicePermissionDenied(err error) bool {
	var svcErr *OrderTrackingServiceError
	return errors.As(err, &svcErr) && svcErr.Code == OrderTrackingServiceErrCodePermissionDenied
}

// IsOrderTrackingServiceUnauthenticated checks if the error is an unauthenticated error
func IsOrderTrackingServiceUnauthenticated(err error) bool {
	var svcErr *OrderTrackingServiceError
	return errors.As(err, &svcErr) && svcErr.Code == OrderTrackingServiceErrCodeUnauthenticated
}

// IsOrderTrackingServiceInternal checks if the error is an internal error
func IsOrderTrackingServiceInternal(err error) bool {
	var svcErr *OrderTrackingServiceError
	return errors.As(err, &svcErr) && svcErr.Code == OrderTrackingServiceErrCodeInternal
}

// IsOrderTrackingServiceUnavailable checks if the error is an unavailable error
func IsOrderTrackingServiceUnavailable(err error) bool {
	var svcErr *OrderTrackingServiceError
	return errors.As(err, &svcErr) && svcErr.Code == OrderTrackingServiceErrCodeUnavailable
}

// GetOrderTrackingServiceErrorCode extracts the error code from an error, returns empty string if not a OrderTrackingServiceError
func GetOrderTrackingServiceErrorCode(err error) string {
	var svcErr *OrderTrackingServiceError
	if errors.As(err, &svcErr) {
		return svcErr.Code
	}
	return ""
}

// NewOrderTrackingServiceInvalidArgumentError creates a new invalid argument error
func NewOrderTrackingServiceInvalidArgumentError(method, message string) error {
	return &OrderTrackingServiceError{Code: OrderTrackingServiceErrCodeInvalidArgument, Method: method, Message: message}
}

// NewOrderTrackingServiceNotFoundError creates a new not found error
func NewOrderTrackingServiceNotFoundError(method, message string) error {
	return &OrderTrackingServiceError{Code: OrderTrackingServiceErrCodeNotFound, Method: method, Message: message}
}

// NewOrderTrackingServiceAlreadyExistsError creates a new already exists error
func NewOrderTrackingServiceAlreadyExistsError(method, message string) error {
	return &OrderTrackingServiceError{Code: OrderTrackingServiceErrCodeAlreadyExists, Method: method, Message: message}
}

// NewOrderTrackingServicePermissionDeniedError creates a new permission denied error
func NewOrderTrackingServicePermissionDeniedError(method, message string) error {
	return &OrderTrackingServiceError{Code: OrderTrackingServiceErrCodePermissionDenied, Method: method, Message: message}
}

// NewOrderTrackingServiceUnauthenticatedError creates a new unauthenticated error
func NewOrderTrackingServiceUnauthenticatedError(method, message string) error {
	return &OrderTrackingServiceError{Code: OrderTrackingServiceErrCodeUnauthenticated, Method: method, Message: message}
}

// NewOrderTrackingServiceInternalError creates a new internal error
func NewOrderTrackingServiceInternalError(method, message string) error {
	return &OrderTrackingServiceError{Code: OrderTrackingServiceErrCodeInternal, Method: method, Message: message}
}

// NewOrderTrackingServiceUnavailableError creates a new unavailable error
func NewOrderTrackingServiceUnavailableError(method, message string) error {
	return &OrderTrackingServiceError{Code: OrderTrackingServiceErrCodeUnavailable, Method: method, Message: message}
}

// OrderTrackingServiceNats is the NATS service interface for OrderTrackingService
type OrderTrackingServiceNats interface {
	TrackOrder(context.Context, *TrackOrderRequest) (*TrackOrderResponse, error)
	UpdateTracking(context.Context, *UpdateTrackingRequest) (*UpdateTrackingResponse, error)
}

// OrderTrackingServiceEndpointInfo describes a service endpoint
type OrderTrackingServiceEndpointInfo struct {
	Name    string `json:"name"`    // Method name (e.g., "CreateProduct")
	Subject string `json:"subject"` // NATS subject (e.g., "api.v1.create_product")
}

// OrderTrackingServiceService is the interface for the registered NATS micro service
// This interface allows for easier dependency injection and testing
type OrderTrackingServiceService interface {
	micro.Service
	Endpoints() []OrderTrackingServiceEndpointInfo
}

// orderTrackingServiceService is the concrete implementation of OrderTrackingServiceService
type orderTrackingServiceService struct {
	micro.Service
	subjectPrefix string
}

// Endpoints returns information about all service endpoints
// This is useful for debugging, monitoring, and service discovery
func (s *orderTrackingServiceService) Endpoints() []OrderTrackingServiceEndpointInfo {
	return []OrderTrackingServiceEndpointInfo{
		{Name: "TrackOrder", Subject: s.subjectPrefix + ".track_order"},
		{Name: "UpdateTracking", Subject: s.subjectPrefix + ".update_tracking"},
	}
}

// RegisterOrderTrackingServiceHandlers registers the service with NATS micro handlers
// Service: order_tracking_service v1.0.0
// Description: Order tracking service
// Subject prefix: api.v1
// Configuration options: WithName(), WithVersion(), WithDescription(), WithSubjectPrefix(), WithTimeout()
// Metadata options: WithMetadata() (replace), WithAdditionalMetadata() (merge)
// Handler options: WithStatsHandler(), WithDoneHandler(), WithErrorHandler()
//
// Endpoint metadata can be configured via proto options (nats.micro.endpoint).metadata
func RegisterOrderTrackingServiceHandlers(nc *nats.Conn, impl OrderTrackingServiceNats, opts ...RegisterOption) (OrderTrackingServiceService, error) {
	cfg := &registerConfig{
		name:          "order_tracking_service",
		version:       "1.0.0",
		description:   "Order tracking service",
		subjectPrefix: "api.v1",
		timeout:       0 * time.Second, // Service-level timeout (0 = no timeout)
		metadata:      map[string]string{},
	}
	for _, opt := range opts {
		opt(cfg)
	}

	svc, err := micro.AddService(nc, micro.Config{
		Name:         cfg.name,
		Version:      cfg.version,
		Metadata:     cfg.metadata,
		Description:  cfg.description,
		StatsHandler: cfg.statsHandler,
		DoneHandler:  cfg.doneHandler,
		ErrorHandler: cfg.errorHandler,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to add service: %w", err)
	}

	// Chain server interceptors
	var chainedInterceptor UnaryServerInterceptor
	if len(cfg.serverInterceptors) > 0 {
		chainedInterceptor = chainUnaryServerInterceptors(cfg.serverInterceptors)
	}

	handlers := &orderTrackingServiceHandlers{
		impl:           impl,
		serviceTimeout: cfg.timeout,
		useJSON:        false,
		interceptor:    chainedInterceptor,
		js:             cfg.js,
	}

	// Map of endpoint names to their handlers
	endpoints := map[string]micro.Handler{

		"track_order": micro.HandlerFunc(handlers.TrackOrder),

		"update_tracking": micro.HandlerFunc(handlers.UpdateTracking),
	}

	// Map of endpoint names to their metadata
	endpointMetadata := map[string]map[string]string{

		"track_order": {},

		"update_tracking": {},
	}

	// Use interface to handle both Service and Group
	type endpointAdder interface {
		AddEndpoint(string, micro.Handler, ...micro.EndpointOpt) error
	}

	var adder endpointAdder = svc
	if cfg.subjectPrefix != "" {
		adder = svc.AddGroup(cfg.subjectPrefix)
	}

	// Register all endpoints with their metadata
	for name, handler := range endpoints {
		opts := []micro.EndpointOpt{}
		if metadata, exists := endpointMetadata[name]; exists && len(metadata) > 0 {
			opts = append(opts, micro.WithEndpointMetadata(metadata))
		}
		if err := adder.AddEndpoint(name, handler, opts...); err != nil {
			return nil, fmt.Errorf("failed to add endpoint %s: %w", name, err)
		}
	}

	return &orderTrackingServiceService{
		Service:       svc,
		subjectPrefix: cfg.subjectPrefix,
	}, nil
}

// orderTrackingServiceHandlers wraps the service implementation with NATS handlers
type orderTrackingServiceHandlers struct {
	impl           OrderTrackingServiceNats
	serviceTimeout time.Duration          // Default timeout for all endpoints
	useJSON        bool                   // Use JSON encoding instead of binary protobuf
	interceptor    UnaryServerInterceptor // Chained interceptors
	js             jetstream.JetStream    // Optional JetStream context for KV/ObjectStore
}

func (h *orderTrackingServiceHandlers) TrackOrder(req micro.Request) {
	// Determine effective timeout: endpoint-specific timeout overrides service timeout
	// If endpoint timeout is set (> 0), use it; otherwise use service timeout
	timeout := h.serviceTimeout

	// Create context with timeout if configured, otherwise use background context
	ctx := context.Background()
	var cancel context.CancelFunc
	if timeout > 0 {
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}

	// Add incoming NATS headers to context so service methods can access them
	if req.Headers() != nil {
		ctx = WithIncomingHeaders(ctx, req.Headers())
	}

	// Initialize outgoing headers pointer in context so interceptors can set response headers
	outgoingHeadersPtr := &nats.Header{}
	ctx = context.WithValue(ctx, outgoingHeadersKey, outgoingHeadersPtr)

	var msg TrackOrderRequest
	if h.useJSON {
		if err := protojson.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(OrderTrackingServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode JSON request: %v", err), nil)
			return
		}
	} else {
		if err := proto.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(OrderTrackingServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode request: %v", err), nil)
			return
		}
	}

	// Define the handler function
	handler := func(ctx context.Context, request interface{}) (interface{}, error) {
		typedReq, ok := request.(*TrackOrderRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type")
		}
		return h.impl.TrackOrder(ctx, typedReq)
	}

	// Execute through interceptor chain if configured
	var resp interface{}
	var err error
	if h.interceptor != nil {
		info := &UnaryServerInfo{
			Service: "OrderTrackingService",
			Method:  "TrackOrder",
			Subject: "api.v1.track_order",
		}
		resp, err = h.interceptor(ctx, &msg, info, handler)
	} else {
		resp, err = handler(ctx, &msg)
	}
	if err != nil {
		// Check if error implements custom status code/message/data methods
		code := OrderTrackingServiceErrCodeInternal
		message := err.Error()
		var data []byte

		// Check for NatsErrorCode() string method
		if coder, ok := err.(interface{ NatsErrorCode() string }); ok {
			code = coder.NatsErrorCode()
		}
		// Check for NatsErrorMessage() string method
		if messager, ok := err.(interface{ NatsErrorMessage() string }); ok {
			message = messager.NatsErrorMessage()
		}
		// Check for NatsErrorData() []byte method
		if dataProvider, ok := err.(interface{ NatsErrorData() []byte }); ok {
			data = dataProvider.NatsErrorData()
		}

		req.Error(code, message, data)
		return
	}

	// Type assert response back to the expected type
	typedResp, ok := resp.(*TrackOrderResponse)
	if !ok {
		req.Error(OrderTrackingServiceErrCodeInternal, "invalid response type from handler", nil)
		return
	}

	var data []byte
	if h.useJSON {
		data, err = protojson.Marshal(typedResp)
		if err != nil {
			req.Error(OrderTrackingServiceErrCodeInternal, fmt.Sprintf("failed to encode JSON response: %v", err), nil)
			return
		}
	} else {
		data, err = proto.Marshal(typedResp)
		if err != nil {
			req.Error(OrderTrackingServiceErrCodeInternal, fmt.Sprintf("failed to encode response: %v", err), nil)
			return
		}
	}

	// Check if context has outgoing headers set by interceptors
	// Read from the pointer that was initialized at the start
	var outgoingHeaders nats.Header
	if headersPtr, ok := ctx.Value(outgoingHeadersKey).(*nats.Header); ok && headersPtr != nil {
		outgoingHeaders = *headersPtr
	}

	if len(outgoingHeaders) > 0 {
		// Send response with headers using micro.WithHeaders
		// Convert nats.Header to micro.Headers (they are the same underlying type)
		if err := req.Respond(data, micro.WithHeaders(micro.Headers(outgoingHeaders))); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for TrackOrder: %v\n", err)
		}
	} else {
		// Send response without headers
		if err := req.Respond(data); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for TrackOrder: %v\n", err)
		}
	}
}

func (h *orderTrackingServiceHandlers) UpdateTracking(req micro.Request) {
	// Determine effective timeout: endpoint-specific timeout overrides service timeout
	// If endpoint timeout is set (> 0), use it; otherwise use service timeout
	timeout := h.serviceTimeout

	// Create context with timeout if configured, otherwise use background context
	ctx := context.Background()
	var cancel context.CancelFunc
	if timeout > 0 {
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}

	// Add incoming NATS headers to context so service methods can access them
	if req.Headers() != nil {
		ctx = WithIncomingHeaders(ctx, req.Headers())
	}

	// Initialize outgoing headers pointer in context so interceptors can set response headers
	outgoingHeadersPtr := &nats.Header{}
	ctx = context.WithValue(ctx, outgoingHeadersKey, outgoingHeadersPtr)

	var msg UpdateTrackingRequest
	if h.useJSON {
		if err := protojson.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(OrderTrackingServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode JSON request: %v", err), nil)
			return
		}
	} else {
		if err := proto.Unmarshal(req.Data(), &msg); err != nil {
			req.Error(OrderTrackingServiceErrCodeInvalidArgument, fmt.Sprintf("failed to decode request: %v", err), nil)
			return
		}
	}

	// Define the handler function
	handler := func(ctx context.Context, request interface{}) (interface{}, error) {
		typedReq, ok := request.(*UpdateTrackingRequest)
		if !ok {
			return nil, fmt.Errorf("invalid request type")
		}
		return h.impl.UpdateTracking(ctx, typedReq)
	}

	// Execute through interceptor chain if configured
	var resp interface{}
	var err error
	if h.interceptor != nil {
		info := &UnaryServerInfo{
			Service: "OrderTrackingService",
			Method:  "UpdateTracking",
			Subject: "api.v1.update_tracking",
		}
		resp, err = h.interceptor(ctx, &msg, info, handler)
	} else {
		resp, err = handler(ctx, &msg)
	}
	if err != nil {
		// Check if error implements custom status code/message/data methods
		code := OrderTrackingServiceErrCodeInternal
		message := err.Error()
		var data []byte

		// Check for NatsErrorCode() string method
		if coder, ok := err.(interface{ NatsErrorCode() string }); ok {
			code = coder.NatsErrorCode()
		}
		// Check for NatsErrorMessage() string method
		if messager, ok := err.(interface{ NatsErrorMessage() string }); ok {
			message = messager.NatsErrorMessage()
		}
		// Check for NatsErrorData() []byte method
		if dataProvider, ok := err.(interface{ NatsErrorData() []byte }); ok {
			data = dataProvider.NatsErrorData()
		}

		req.Error(code, message, data)
		return
	}

	// Type assert response back to the expected type
	typedResp, ok := resp.(*UpdateTrackingResponse)
	if !ok {
		req.Error(OrderTrackingServiceErrCodeInternal, "invalid response type from handler", nil)
		return
	}

	var data []byte
	if h.useJSON {
		data, err = protojson.Marshal(typedResp)
		if err != nil {
			req.Error(OrderTrackingServiceErrCodeInternal, fmt.Sprintf("failed to encode JSON response: %v", err), nil)
			return
		}
	} else {
		data, err = proto.Marshal(typedResp)
		if err != nil {
			req.Error(OrderTrackingServiceErrCodeInternal, fmt.Sprintf("failed to encode response: %v", err), nil)
			return
		}
	}

	// Check if context has outgoing headers set by interceptors
	// Read from the pointer that was initialized at the start
	var outgoingHeaders nats.Header
	if headersPtr, ok := ctx.Value(outgoingHeadersKey).(*nats.Header); ok && headersPtr != nil {
		outgoingHeaders = *headersPtr
	}

	if len(outgoingHeaders) > 0 {
		// Send response with headers using micro.WithHeaders
		// Convert nats.Header to micro.Headers (they are the same underlying type)
		if err := req.Respond(data, micro.WithHeaders(micro.Headers(outgoingHeaders))); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for UpdateTracking: %v\n", err)
		}
	} else {
		// Send response without headers
		if err := req.Respond(data); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for UpdateTracking: %v\n", err)
		}
	}
}

// OrderTrackingServiceNatsClientInterface is the interface for the NATS client
// This interface allows for easier dependency injection and testing
type OrderTrackingServiceNatsClientInterface interface {
	TrackOrder(context.Context, *TrackOrderRequest) (*TrackOrderResponse, error)
	UpdateTracking(context.Context, *UpdateTrackingRequest) (*UpdateTrackingResponse, error)
	Endpoints() []OrderTrackingServiceEndpointInfo
}

// OrderTrackingServiceNatsClient is the concrete implementation of OrderTrackingServiceNatsClientInterface
type OrderTrackingServiceNatsClient struct {
	nc            *nats.Conn
	subjectPrefix string
	useJSON       bool                   // Use JSON encoding instead of binary protobuf
	interceptor   UnaryClientInterceptor // Chained interceptors
	js            jetstream.JetStream    // Optional JetStream for KV/ObjectStore reads
}

// NewOrderTrackingServiceNatsClient creates a new NATS client for OrderTrackingService.
// The client sends requests over NATS using protobuf serialization (or JSON if configured).
func NewOrderTrackingServiceNatsClient(nc *nats.Conn, opts ...NatsClientOption) OrderTrackingServiceNatsClientInterface {
	cfg := &natsClientConfig{
		subjectPrefix: "api.v1",
	}
	for _, opt := range opts {
		opt.applyNatsClientOption(cfg)
	}

	// Chain client interceptors
	var chainedInterceptor UnaryClientInterceptor
	if len(cfg.clientInterceptors) > 0 {
		chainedInterceptor = chainUnaryClientInterceptors(cfg.clientInterceptors)
	}

	c := &OrderTrackingServiceNatsClient{
		nc:            nc,
		subjectPrefix: cfg.subjectPrefix,
		useJSON:       false,
		interceptor:   chainedInterceptor,
		js:            cfg.js,
	}
	return c
}

// TrackOrder sends a TrackOrder request to the service via NATS.
// Returns an error if the request fails or the service returns an error.
func (c *OrderTrackingServiceNatsClient) TrackOrder(ctx context.Context, req *TrackOrderRequest) (*TrackOrderResponse, error) {
	method := "TrackOrder"

	// Pointer to store response headers - stored in context so invoker can update it
	responseHeadersPtr := &nats.Header{}

	// Add the response headers pointer to context so invoker can populate it
	// Interceptors can then read the headers from the same context
	ctx = context.WithValue(ctx, responseHeadersKey, responseHeadersPtr)

	// Define the invoker function that performs the actual NATS call
	invoker := func(invokerCtx context.Context, method string, request, reply interface{}) error {
		subject := c.subjectPrefix + ".track_order"

		// Marshal request
		typedReq, ok := request.(*TrackOrderRequest)
		if !ok {
			return fmt.Errorf("invalid request type")
		}

		var data []byte
		var err error
		if c.useJSON {
			data, err = protojson.Marshal(typedReq)
		} else {
			data, err = proto.Marshal(typedReq)
		}
		if err != nil {
			return err
		}

		// Extract outgoing headers from context and attach to NATS message
		var msg *nats.Msg
		if headers := OutgoingHeaders(invokerCtx); headers != nil {
			msg, err = c.nc.RequestMsgWithContext(invokerCtx, &nats.Msg{
				Subject: subject,
				Data:    data,
				Header:  headers,
			})
		} else {
			msg, err = c.nc.RequestWithContext(invokerCtx, subject, data)
		}
		if err != nil {
			return err
		}

		// Store response headers in the pointer from context
		if msg.Header != nil && len(msg.Header) > 0 {
			if headersPtr, ok := invokerCtx.Value(responseHeadersKey).(*nats.Header); ok && headersPtr != nil {
				*headersPtr = msg.Header
			}
		} // Check if this is an error response from the service
		if msg.Header.Get("Status") != "" {
			code := msg.Header.Get("Status")
			description := msg.Header.Get("Description")
			return &OrderTrackingServiceError{
				Code:    code,
				Method:  method,
				Message: description,
			}
		}

		// Unmarshal response
		typedReply, ok := reply.(*TrackOrderResponse)
		if !ok {
			return fmt.Errorf("invalid reply type")
		}

		if c.useJSON {
			err = protojson.Unmarshal(msg.Data, typedReply)
		} else {
			err = proto.Unmarshal(msg.Data, typedReply)
		}
		return err
	}

	var resp TrackOrderResponse

	// Execute through interceptor chain if configured
	var err error
	if c.interceptor != nil {
		err = c.interceptor(ctx, method, req, &resp, invoker)
	} else {
		err = invoker(ctx, method, req, &resp)
	}

	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// UpdateTracking sends a UpdateTracking request to the service via NATS.
// Returns an error if the request fails or the service returns an error.
func (c *OrderTrackingServiceNatsClient) UpdateTracking(ctx context.Context, req *UpdateTrackingRequest) (*UpdateTrackingResponse, error) {
	method := "UpdateTracking"

	// Pointer to store response headers - stored in context so invoker can update it
	responseHeadersPtr := &nats.Header{}

	// Add the response headers pointer to context so invoker can populate it
	// Interceptors can then read the headers from the same context
	ctx = context.WithValue(ctx, responseHeadersKey, responseHeadersPtr)

	// Define the invoker function that performs the actual NATS call
	invoker := func(invokerCtx context.Context, method string, request, reply interface{}) error {
		subject := c.subjectPrefix + ".update_tracking"

		// Marshal request
		typedReq, ok := request.(*UpdateTrackingRequest)
		if !ok {
			return fmt.Errorf("invalid request type")
		}

		var data []byte
		var err error
		if c.useJSON {
			data, err = protojson.Marshal(typedReq)
		} else {
			data, err = proto.Marshal(typedReq)
		}
		if err != nil {
			return err
		}

		// Extract outgoing headers from context and attach to NATS message
		var msg *nats.Msg
		if headers := OutgoingHeaders(invokerCtx); headers != nil {
			msg, err = c.nc.RequestMsgWithContext(invokerCtx, &nats.Msg{
				Subject: subject,
				Data:    data,
				Header:  headers,
			})
		} else {
			msg, err = c.nc.RequestWithContext(invokerCtx, subject, data)
		}
		if err != nil {
			return err
		}

		// Store response headers in the pointer from context
		if msg.Header != nil && len(msg.Header) > 0 {
			if headersPtr, ok := invokerCtx.Value(responseHeadersKey).(*nats.Header); ok && headersPtr != nil {
				*headersPtr = msg.Header
			}
		} // Check if this is an error response from the service
		if msg.Header.Get("Status") != "" {
			code := msg.Header.Get("Status")
			description := msg.Header.Get("Description")
			return &OrderTrackingServiceError{
				Code:    code,
				Method:  method,
				Message: description,
			}
		}

		// Unmarshal response
		typedReply, ok := reply.(*UpdateTrackingResponse)
		if !ok {
			return fmt.Errorf("invalid reply type")
		}

		if c.useJSON {
			err = protojson.Unmarshal(msg.Data, typedReply)
		} else {
			err = proto.Unmarshal(msg.Data, typedReply)
		}
		return err
	}

	var resp UpdateTrackingResponse

	// Execute through interceptor chain if configured
	var err error
	if c.interceptor != nil {
		err = c.interceptor(ctx, method, req, &resp, invoker)
	} else {
		err = invoker(ctx, method, req, &resp)
	}

	if err != nil {
		return nil, err
	}

	return &resp, nil
}

// Endpoints returns information about all service endpoints this client can call.
// This is useful for debugging, monitoring, and introspection.
func (c *OrderTrackingServiceNatsClient) Endpoints() []OrderTrackingServiceEndpointInfo {
	return []OrderTrackingServiceEndpointInfo{
		{Name: "TrackOrder", Subject: c.subjectPrefix + ".track_order"},
		{Name: "UpdateTracking", Subject: c.subjectPrefix + ".update_tracking"},
	}
}
