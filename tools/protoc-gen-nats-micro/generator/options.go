package generator

import (
	"fmt"
	"time"

	natspb "github.com/toyz/protoc-gen-nats-micro/tools/protoc-gen-nats-micro/nats/micro"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

// ServiceOptions contains metadata about a service
type ServiceOptions struct {
	SubjectPrefix string
	Name          string
	Version       string
	Description   string
	Metadata      map[string]string
	Timeout       time.Duration
	Skip          bool // Skip generation for this service
	UseJSON       bool // Use JSON encoding instead of binary protobuf
}

// GetServiceOptions extracts service options from proto service definition
func GetServiceOptions(service *protogen.Service) ServiceOptions {
	serviceName := service.GoName
	subjectPrefix := ToSnakeCase(serviceName)

	// Defaults
	opts := ServiceOptions{
		Name:          serviceName, // Use actual service name (e.g., "ProductService")
		Version:       "1.0.0",
		Description:   fmt.Sprintf("%s - generated by protoc-gen-nats-micro", serviceName),
		SubjectPrefix: subjectPrefix, // Default to snake_case (e.g., "product_service")
		Metadata:      make(map[string]string),
		Timeout:       0, // No timeout by default
	}

	// Try to read the nats.micro.service extension
	if service.Desc.Options() != nil && proto.HasExtension(service.Desc.Options(), natspb.E_Service) {
		ext := proto.GetExtension(service.Desc.Options(), natspb.E_Service)
		if svcOpts, ok := ext.(*natspb.ServiceOptions); ok {
			// Check skip first - if true, mark it and return early
			if svcOpts.Skip {
				opts.Skip = true
				return opts
			}

			if svcOpts.SubjectPrefix != "" {
				opts.SubjectPrefix = svcOpts.SubjectPrefix
			}
			if svcOpts.Name != "" {
				opts.Name = svcOpts.Name
			}
			if svcOpts.Version != "" {
				opts.Version = svcOpts.Version
			}
			if svcOpts.Description != "" {
				opts.Description = svcOpts.Description
			}
			if len(svcOpts.Metadata) > 0 {
				opts.Metadata = svcOpts.Metadata
			}
			if svcOpts.Timeout != nil {
				opts.Timeout = svcOpts.Timeout.AsDuration()
			}
			opts.UseJSON = svcOpts.Json
		}
	}

	return opts
}

// EndpointOptions contains metadata about an endpoint
type EndpointOptions struct {
	Skip        bool              // Skip generation for this endpoint
	Timeout     time.Duration     // Endpoint-specific timeout (0 = use service default)
	Metadata    map[string]string // Endpoint-specific metadata
	KVStore     *KVStoreOpts      // KV store options (nil if not set)
	ObjectStore *ObjectStoreOpts  // Object store options (nil if not set)
	Stream      *StreamOpts       // Streaming options (nil if not set)
}

// KVStoreOpts contains KV store persistence options for a method
type KVStoreOpts struct {
	Bucket      string // KV bucket name
	KeyTemplate string // Key template with {field} placeholders
}

// ObjectStoreOpts contains object store options for a method
type ObjectStoreOpts struct {
	Bucket      string // Object store bucket name
	KeyTemplate string // Key template with {field} placeholders
}

// StreamOpts contains streaming fine-tuning options
type StreamOpts struct {
	MaxInflight int32 // Max concurrent in-flight messages (0 = unlimited)
	Ordered     bool  // Guarantee ordering via sequence headers
}

// GetEndpointOptions extracts endpoint options from proto method definition
func GetEndpointOptions(method *protogen.Method) EndpointOptions {
	opts := EndpointOptions{
		Skip:     false,
		Timeout:  0, // 0 means use service default
		Metadata: make(map[string]string),
	}

	// Try to read the natsmicro.endpoint extension
	if method.Desc.Options() != nil && proto.HasExtension(method.Desc.Options(), natspb.E_Endpoint) {
		ext := proto.GetExtension(method.Desc.Options(), natspb.E_Endpoint)
		if endpointOpts, ok := ext.(*natspb.EndpointOptions); ok {
			opts.Skip = endpointOpts.Skip
			if endpointOpts.Timeout != nil {
				opts.Timeout = endpointOpts.Timeout.AsDuration()
			}
			if len(endpointOpts.Metadata) > 0 {
				opts.Metadata = endpointOpts.Metadata
			}
		}
	}

	// Try to read the natsmicro.kv_store extension
	if method.Desc.Options() != nil && proto.HasExtension(method.Desc.Options(), natspb.E_KvStore) {
		ext := proto.GetExtension(method.Desc.Options(), natspb.E_KvStore)
		if kvOpts, ok := ext.(*natspb.KVStoreOptions); ok && kvOpts.Bucket != "" {
			opts.KVStore = &KVStoreOpts{
				Bucket:      kvOpts.Bucket,
				KeyTemplate: kvOpts.KeyTemplate,
			}
		}
	}

	// Try to read the natsmicro.object_store extension
	if method.Desc.Options() != nil && proto.HasExtension(method.Desc.Options(), natspb.E_ObjectStore) {
		ext := proto.GetExtension(method.Desc.Options(), natspb.E_ObjectStore)
		if objOpts, ok := ext.(*natspb.ObjectStoreOptions); ok && objOpts.Bucket != "" {
			opts.ObjectStore = &ObjectStoreOpts{
				Bucket:      objOpts.Bucket,
				KeyTemplate: objOpts.KeyTemplate,
			}
		}
	}

	// Try to read the natsmicro.stream extension
	if method.Desc.Options() != nil && proto.HasExtension(method.Desc.Options(), natspb.E_Stream) {
		ext := proto.GetExtension(method.Desc.Options(), natspb.E_Stream)
		if streamOpts, ok := ext.(*natspb.StreamOptions); ok {
			opts.Stream = &StreamOpts{
				MaxInflight: streamOpts.MaxInflight,
				Ordered:     streamOpts.Ordered,
			}
		}
	}

	return opts
}

// IsServerStreaming returns true if the method has server-side streaming
func IsServerStreaming(method *protogen.Method) bool {
	return method.Desc.IsStreamingServer()
}

// IsClientStreaming returns true if the method has client-side streaming
func IsClientStreaming(method *protogen.Method) bool {
	return method.Desc.IsStreamingClient()
}

// IsBidiStreaming returns true if the method has bidirectional streaming
func IsBidiStreaming(method *protogen.Method) bool {
	return method.Desc.IsStreamingServer() && method.Desc.IsStreamingClient()
}

// IsUnary returns true if the method is a standard unary RPC
func IsUnary(method *protogen.Method) bool {
	return !method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient()
}
