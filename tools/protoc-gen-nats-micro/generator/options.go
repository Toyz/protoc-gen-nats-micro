package generator

import (
	"fmt"
	"time"

	natspb "github.com/toyz/protoc-gen-nats-micro/tools/protoc-gen-nats-micro/nats/micro"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/runtime/protoimpl"
)

// getExtension is a generic helper that checks for and retrieves a proto extension
// in one step, eliminating the repeated nil-check + HasExtension + GetExtension + type-assert chain.
func getExtension[T any](opts protoreflect.ProtoMessage, ext *protoimpl.ExtensionInfo) (T, bool) {
	var zero T
	if opts == nil || !proto.HasExtension(opts, ext) {
		return zero, false
	}
	val, ok := proto.GetExtension(opts, ext).(T)
	return val, ok
}

// ServiceOptions contains metadata about a service
type ServiceOptions struct {
	SubjectPrefix string
	Name          string
	Version       string
	Description   string
	Metadata      map[string]string
	Timeout       time.Duration
	Skip          bool     // Skip generation for this service
	UseJSON       bool     // Use JSON encoding instead of binary protobuf
	ErrorCodes    []string // Custom application-specific error codes
}

// GetServiceOptions extracts service options from proto service definition
func GetServiceOptions(service *protogen.Service) ServiceOptions {
	serviceName := service.GoName
	subjectPrefix := ToSnakeCase(serviceName)

	// Defaults
	opts := ServiceOptions{
		Name:          serviceName, // Use actual service name (e.g., "ProductService")
		Version:       "1.0.0",
		Description:   fmt.Sprintf("%s - generated by protoc-gen-nats-micro", serviceName),
		SubjectPrefix: subjectPrefix, // Default to snake_case (e.g., "product_service")
		Metadata:      make(map[string]string),
		Timeout:       0, // No timeout by default
	}

	// Try to read the nats.micro.service extension
	if svcOpts, ok := getExtension[*natspb.ServiceOptions](service.Desc.Options(), natspb.E_Service); ok {
		// Check skip first - if true, mark it and return early
		if svcOpts.Skip {
			opts.Skip = true
			return opts
		}

		if svcOpts.SubjectPrefix != "" {
			opts.SubjectPrefix = svcOpts.SubjectPrefix
		}
		if svcOpts.Name != "" {
			opts.Name = svcOpts.Name
		}
		if svcOpts.Version != "" {
			opts.Version = svcOpts.Version
		}
		if svcOpts.Description != "" {
			opts.Description = svcOpts.Description
		}
		if len(svcOpts.Metadata) > 0 {
			opts.Metadata = svcOpts.Metadata
		}
		if svcOpts.Timeout != nil {
			opts.Timeout = svcOpts.Timeout.AsDuration()
		}
		opts.UseJSON = svcOpts.Json
		if len(svcOpts.ErrorCodes) > 0 {
			opts.ErrorCodes = svcOpts.ErrorCodes
		}
	}

	return opts
}

// EndpointOptions contains metadata about an endpoint
type EndpointOptions struct {
	Skip        bool              // Skip generation for this endpoint
	Timeout     time.Duration     // Endpoint-specific timeout (0 = use service default)
	Metadata    map[string]string // Endpoint-specific metadata
	KVStore     *KVStoreOpts      // KV store options (nil if not set)
	ObjectStore *ObjectStoreOpts  // Object store options (nil if not set)
	Stream      *StreamOpts       // Streaming options (nil if not set)
}

// KVStoreOpts contains KV store persistence options for a method
type KVStoreOpts struct {
	Bucket      string        // KV bucket name
	KeyTemplate string        // Key template with {field} placeholders
	TTL         time.Duration // TTL for entries (0 = no expiry)
	Description string        // Human-readable bucket description
	MaxHistory  int32         // Revisions per key (0 = default 1, max 64)
	ClientOnly  bool          // Skip server auto-persist; only generate client read/write
}

// ObjectStoreOpts contains object store options for a method
type ObjectStoreOpts struct {
	Bucket      string        // Object store bucket name
	KeyTemplate string        // Key template with {field} placeholders
	TTL         time.Duration // TTL for objects (0 = no expiry)
	Description string        // Human-readable bucket description
	ClientOnly  bool          // Skip server auto-persist; only generate client read/write
}

// StreamOpts contains streaming fine-tuning options
type StreamOpts struct {
	MaxInflight int32 // Max concurrent in-flight messages (0 = unlimited)
	Ordered     bool  // Guarantee ordering via sequence headers
}

// GetEndpointOptions extracts endpoint options from proto method definition
func GetEndpointOptions(method *protogen.Method) EndpointOptions {
	opts := EndpointOptions{
		Skip:     false,
		Timeout:  0, // 0 means use service default
		Metadata: make(map[string]string),
	}

	methodOpts := method.Desc.Options()

	// Endpoint options
	if endpointOpts, ok := getExtension[*natspb.EndpointOptions](methodOpts, natspb.E_Endpoint); ok {
		opts.Skip = endpointOpts.Skip
		if endpointOpts.Timeout != nil {
			opts.Timeout = endpointOpts.Timeout.AsDuration()
		}
		if len(endpointOpts.Metadata) > 0 {
			opts.Metadata = endpointOpts.Metadata
		}
	}

	// KV Store options
	if kvOpts, ok := getExtension[*natspb.KVStoreOptions](methodOpts, natspb.E_KvStore); ok && kvOpts.Bucket != "" {
		kv := &KVStoreOpts{
			Bucket:      kvOpts.Bucket,
			KeyTemplate: kvOpts.KeyTemplate,
			Description: kvOpts.Description,
			MaxHistory:  kvOpts.MaxHistory,
			ClientOnly:  kvOpts.ClientOnly,
		}
		if kvOpts.Ttl != nil {
			kv.TTL = kvOpts.Ttl.AsDuration()
		}
		opts.KVStore = kv
	}

	// Object Store options
	if objOpts, ok := getExtension[*natspb.ObjectStoreOptions](methodOpts, natspb.E_ObjectStore); ok && objOpts.Bucket != "" {
		obj := &ObjectStoreOpts{
			Bucket:      objOpts.Bucket,
			KeyTemplate: objOpts.KeyTemplate,
			Description: objOpts.Description,
			ClientOnly:  objOpts.ClientOnly,
		}
		if objOpts.Ttl != nil {
			obj.TTL = objOpts.Ttl.AsDuration()
		}
		opts.ObjectStore = obj
	}

	// Stream options
	if streamOpts, ok := getExtension[*natspb.StreamOptions](methodOpts, natspb.E_Stream); ok {
		opts.Stream = &StreamOpts{
			MaxInflight: streamOpts.MaxInflight,
			Ordered:     streamOpts.Ordered,
		}
	}

	return opts
}

// IsServerStreaming returns true if the method has server-side streaming
func IsServerStreaming(method *protogen.Method) bool {
	return method.Desc.IsStreamingServer()
}

// IsClientStreaming returns true if the method has client-side streaming
func IsClientStreaming(method *protogen.Method) bool {
	return method.Desc.IsStreamingClient()
}

// IsBidiStreaming returns true if the method has bidirectional streaming
func IsBidiStreaming(method *protogen.Method) bool {
	return method.Desc.IsStreamingServer() && method.Desc.IsStreamingClient()
}

// IsUnary returns true if the method is a standard unary RPC
func IsUnary(method *protogen.Method) bool {
	return !method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient()
}
