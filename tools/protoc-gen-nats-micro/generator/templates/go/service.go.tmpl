{{- /* Service interface and registration function */ -}}
{{- if not .Options.SubjectPrefix }}
// WARNING: Service {{.Service.GoName}} is missing required option (nats.micro.service).subject_prefix
// The service will not function correctly without a subject prefix.

{{end -}}
// {{.Service.GoName}}Nats is the NATS service interface for {{.Service.GoName}}
type {{.Service.GoName}}Nats interface {
{{- range .Service.Methods}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
{{- if IsUnary .}}
	{{.GoName}}(context.Context, *{{.Input.GoIdent.GoName}}) (*{{.Output.GoIdent.GoName}}, error)
{{- else if IsServerStreaming .}}
{{- if not (IsClientStreaming .)}}
	{{.GoName}}(context.Context, *{{.Input.GoIdent.GoName}}, *{{$.Service.GoName}}_{{.GoName}}_Stream) error
{{- end}}
{{- end}}
{{- if IsClientStreaming .}}
{{- if not (IsServerStreaming .)}}
	{{.GoName}}(context.Context, *{{$.Service.GoName}}_{{.GoName}}_Stream) (*{{.Output.GoIdent.GoName}}, error)
{{- end}}
{{- end}}
{{- if IsBidiStreaming .}}
	{{.GoName}}(context.Context, *{{$.Service.GoName}}_{{.GoName}}_Stream) error
{{- end}}
{{- end}}
{{- end}}
}

// {{.Service.GoName}}EndpointInfo describes a service endpoint
type {{.Service.GoName}}EndpointInfo struct {
	Name    string `json:"name"`    // Method name (e.g., "CreateProduct")
	Subject string `json:"subject"` // NATS subject (e.g., "api.v1.create_product")
}

// {{.Service.GoName}}Service is the interface for the registered NATS micro service
// This interface allows for easier dependency injection and testing
type {{.Service.GoName}}Service interface {
	micro.Service
	Endpoints() []{{.Service.GoName}}EndpointInfo
}

// {{ToLowerFirst .Service.GoName}}Service is the concrete implementation of {{.Service.GoName}}Service
type {{ToLowerFirst .Service.GoName}}Service struct {
	micro.Service
	subjectPrefix string
}

// Endpoints returns information about all service endpoints
// This is useful for debugging, monitoring, and service discovery
func (s *{{ToLowerFirst .Service.GoName}}Service) Endpoints() []{{.Service.GoName}}EndpointInfo {
	return []{{.Service.GoName}}EndpointInfo{
{{- range .Service.Methods}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
		{Name: "{{.GoName}}", Subject: s.subjectPrefix + ".{{ToSnakeCase .GoName}}"},
{{- end}}
{{- end}}
	}
}

// Register{{.Service.GoName}}Handlers registers the service with NATS micro handlers
// Service: {{.Options.Name}} v{{.Options.Version}}
{{- if .Options.Description}}
// Description: {{.Options.Description}}
{{- end}}
// Subject prefix: {{.Options.SubjectPrefix}}
{{- if .Options.Metadata}}
// Service Metadata: {{range $key, $value := .Options.Metadata}}{{$key}}={{$value}} {{end}}
{{- end}}
// Configuration options: WithName(), WithVersion(), WithDescription(), WithSubjectPrefix(), WithTimeout()
// Metadata options: WithMetadata() (replace), WithAdditionalMetadata() (merge)
// Handler options: WithStatsHandler(), WithDoneHandler(), WithErrorHandler()
// 
// Endpoint metadata can be configured via proto options (nats.micro.endpoint).metadata
func Register{{.Service.GoName}}Handlers(nc *nats.Conn, impl {{.Service.GoName}}Nats, opts ...RegisterOption) ({{.Service.GoName}}Service, error) {
	cfg := &registerConfig{
		name:          "{{.Options.Name}}",
		version:       "{{.Options.Version}}",
		description:   "{{.Options.Description}}",
		subjectPrefix: "{{.Options.SubjectPrefix}}",
		timeout:       {{.Options.Timeout.Seconds}} * time.Second, // Service-level timeout (0 = no timeout)
		metadata:      map[string]string{
{{- range $key, $value := .Options.Metadata}}
			"{{$key}}": "{{$value}}",
{{- end}}
		},
	}
	for _, opt := range opts {
		opt(cfg)
	}

	svc, err := micro.AddService(nc, micro.Config{
		Name:         cfg.name,
		Version:      cfg.version,
		Metadata:     cfg.metadata,
		Description:  cfg.description,
		StatsHandler: cfg.statsHandler,
		DoneHandler:  cfg.doneHandler,
		ErrorHandler: cfg.errorHandler,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to add service: %w", err)
	}

	// Chain server interceptors
	var chainedInterceptor UnaryServerInterceptor
	if len(cfg.serverInterceptors) > 0 {
		chainedInterceptor = chainUnaryServerInterceptors(cfg.serverInterceptors)
	}

	handlers := &{{ToLowerFirst .Service.GoName}}Handlers{
		nc:             nc,
		impl:           impl,
		serviceTimeout: cfg.timeout,
		useJSON:        {{.Options.UseJSON}},
		interceptor:    chainedInterceptor,
		js:             cfg.js,
	}

	// Auto-create KV and Object Store buckets if JetStream is available
	if cfg.js != nil {
		{{- range .Service.Methods}}
		{{- $eopts := GetEndpointOptions .}}
		{{- if $eopts.KVStore}}
		// Auto-create KV bucket "{{$eopts.KVStore.Bucket}}" for {{.GoName}}
		if _, err := cfg.js.CreateOrUpdateKeyValue(context.Background(), jetstream.KeyValueConfig{
			Bucket:      "{{$eopts.KVStore.Bucket}}",
			{{- if $eopts.KVStore.Description}}
			Description: "{{$eopts.KVStore.Description}}",
			{{- end}}
			{{- if $eopts.KVStore.MaxHistory}}
			MaxHistory:  {{$eopts.KVStore.MaxHistory}},
			{{- end}}
			{{- if $eopts.KVStore.TTL.Nanoseconds}}
			TTL:         {{$eopts.KVStore.TTL.Nanoseconds}} * time.Nanosecond,
			{{- end}}
		}); err != nil {
			fmt.Fprintf(os.Stderr, "[nats-micro] WARN: failed to create KV bucket \"{{$eopts.KVStore.Bucket}}\": %v\n", err)
		}
		{{- end}}
		{{- if $eopts.ObjectStore}}
		// Auto-create Object Store bucket "{{$eopts.ObjectStore.Bucket}}" for {{.GoName}}
		if _, err := cfg.js.CreateOrUpdateObjectStore(context.Background(), jetstream.ObjectStoreConfig{
			Bucket:      "{{$eopts.ObjectStore.Bucket}}",
			{{- if $eopts.ObjectStore.Description}}
			Description: "{{$eopts.ObjectStore.Description}}",
			{{- end}}
			{{- if $eopts.ObjectStore.TTL.Nanoseconds}}
			TTL:         {{$eopts.ObjectStore.TTL.Nanoseconds}} * time.Nanosecond,
			{{- end}}
		}); err != nil {
			fmt.Fprintf(os.Stderr, "[nats-micro] WARN: failed to create Object Store bucket \"{{$eopts.ObjectStore.Bucket}}\": %v\n", err)
		}
		{{- end}}
		{{- end}}
	}

	// Map of endpoint names to their handlers
	endpoints := map[string]micro.Handler{
{{range .Service.Methods -}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
		"{{ToSnakeCase .GoName}}": micro.HandlerFunc(handlers.{{.GoName}}),
{{end -}}
{{end -}}
	}

	// Map of endpoint names to their metadata
	endpointMetadata := map[string]map[string]string{
{{range .Service.Methods -}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
		"{{ToSnakeCase .GoName}}": {
{{- range $key, $value := $endpointOpts.Metadata}}
			"{{$key}}": "{{$value}}",
{{- end}}
		},
{{end -}}
{{end -}}
	}

	// Use interface to handle both Service and Group
	type endpointAdder interface {
		AddEndpoint(string, micro.Handler, ...micro.EndpointOpt) error
	}

	var adder endpointAdder = svc
	if cfg.subjectPrefix != "" {
		adder = svc.AddGroup(cfg.subjectPrefix)
	}

	// Register all endpoints with their metadata
	for name, handler := range endpoints {
		opts := []micro.EndpointOpt{}
		if metadata, exists := endpointMetadata[name]; exists && len(metadata) > 0 {
			opts = append(opts, micro.WithEndpointMetadata(metadata))
		}
		if err := adder.AddEndpoint(name, handler, opts...); err != nil {
			return nil, fmt.Errorf("failed to add endpoint %s: %w", name, err)
		}
	}

	return &{{ToLowerFirst .Service.GoName}}Service{
		Service:       svc,
		subjectPrefix: cfg.subjectPrefix,
	}, nil
}

// {{ToLowerFirst .Service.GoName}}Handlers wraps the service implementation with NATS handlers
type {{ToLowerFirst .Service.GoName}}Handlers struct {
	nc             *nats.Conn                 // NATS connection for streaming
	impl           {{.Service.GoName}}Nats
	serviceTimeout time.Duration              // Default timeout for all endpoints
	useJSON        bool                       // Use JSON encoding instead of binary protobuf
	interceptor    UnaryServerInterceptor     // Chained interceptors
	js             jetstream.JetStream        // Optional JetStream context for KV/ObjectStore
}

{{range .Service.Methods -}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
{{- if IsUnary .}}
func (h *{{ToLowerFirst $.Service.GoName}}Handlers) {{.GoName}}(req micro.Request) {
	// Determine effective timeout: endpoint-specific timeout overrides service timeout
	// If endpoint timeout is set (> 0), use it; otherwise use service timeout
	timeout := h.serviceTimeout
	{{- if gt $endpointOpts.Timeout.Nanoseconds 0}}
	timeout = {{$endpointOpts.Timeout.Seconds}} * time.Second // Endpoint-specific timeout
	{{- end}}
	
	// Create context with timeout if configured, otherwise use background context
	ctx := context.Background()
	var cancel context.CancelFunc
	if timeout > 0 {
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}

	// Add incoming NATS headers to context so service methods can access them
	if req.Headers() != nil {
		ctx = WithIncomingHeaders(ctx, req.Headers())
	}

	// Initialize outgoing headers pointer in context so interceptors can set response headers
	outgoingHeadersPtr := &nats.Header{}
	ctx = context.WithValue(ctx, outgoingHeadersKey, outgoingHeadersPtr)

	var msg {{.Input.GoIdent.GoName}}
	if h.useJSON {
		if err := protojson.Unmarshal(req.Data(), &msg); err != nil {
			req.Error({{$.Service.GoName}}ErrCodeInvalidArgument, fmt.Sprintf("failed to decode JSON request: %v", err), nil)
			return
		}
	} else {
		if err := proto.Unmarshal(req.Data(), &msg); err != nil {
			req.Error({{$.Service.GoName}}ErrCodeInvalidArgument, fmt.Sprintf("failed to decode request: %v", err), nil)
			return
		}
	}

	// Define the handler function
	handler := func(ctx context.Context, request interface{}) (interface{}, error) {
		typedReq, ok := request.(*{{.Input.GoIdent.GoName}})
		if !ok {
			return nil, fmt.Errorf("invalid request type")
		}
		return h.impl.{{.GoName}}(ctx, typedReq)
	}

	// Execute through interceptor chain if configured
	var resp interface{}
	var err error
	if h.interceptor != nil {
		info := &UnaryServerInfo{
			Service: "{{$.Service.GoName}}",
			Method:  "{{.GoName}}",
			Subject: "{{$.Options.SubjectPrefix}}.{{ToSnakeCase .GoName}}",
		}
		resp, err = h.interceptor(ctx, &msg, info, handler)
	} else {
		resp, err = handler(ctx, &msg)
	}
	if err != nil {
		// Check if error implements custom status code/message/data methods
		code := {{$.Service.GoName}}ErrCodeInternal
		message := err.Error()
		var data []byte

		// Check for NatsErrorCode() string method
		if coder, ok := err.(interface{ NatsErrorCode() string }); ok {
			code = coder.NatsErrorCode()
		}
		// Check for NatsErrorMessage() string method
		if messager, ok := err.(interface{ NatsErrorMessage() string }); ok {
			message = messager.NatsErrorMessage()
		}
		// Check for NatsErrorData() []byte method
		if dataProvider, ok := err.(interface{ NatsErrorData() []byte }); ok {
			data = dataProvider.NatsErrorData()
		}

		req.Error(code, message, data)
		return
	}

	// Type assert response back to the expected type
	typedResp, ok := resp.(*{{.Output.GoIdent.GoName}})
	if !ok {
		req.Error({{$.Service.GoName}}ErrCodeInternal, "invalid response type from handler", nil)
		return
	}

	var data []byte
	if h.useJSON {
		data, err = protojson.Marshal(typedResp)
		if err != nil {
			req.Error({{$.Service.GoName}}ErrCodeInternal, fmt.Sprintf("failed to encode JSON response: %v", err), nil)
			return
		}
	} else {
		data, err = proto.Marshal(typedResp)
		if err != nil {
			req.Error({{$.Service.GoName}}ErrCodeInternal, fmt.Sprintf("failed to encode response: %v", err), nil)
			return
		}
	}

	// Check if context has outgoing headers set by interceptors
	// Read from the pointer that was initialized at the start
	var outgoingHeaders nats.Header
	if headersPtr, ok := ctx.Value(outgoingHeadersKey).(*nats.Header); ok && headersPtr != nil {
		outgoingHeaders = *headersPtr
	}

	{{- /* KV Store persistence: auto-persist response after successful RPC */}}
	{{- if $endpointOpts.KVStore}}
	{{- if not $endpointOpts.KVStore.ClientOnly}}
	// Auto-persist response to KV Store (bucket: "{{$endpointOpts.KVStore.Bucket}}")
	if h.js != nil {
		kvKey := {{ResolveKeyTemplateGo $endpointOpts.KVStore.KeyTemplate .}}
		kv, kvErr := h.js.KeyValue(ctx, "{{$endpointOpts.KVStore.Bucket}}")
		if kvErr != nil {
			fmt.Fprintf(os.Stderr, "[nats-micro] WARN: KV bucket \"{{$endpointOpts.KVStore.Bucket}}\" not available for {{.GoName}}: %v\n", kvErr)
		} else {
			if _, kvErr = kv.Put(ctx, kvKey, data); kvErr != nil {
				fmt.Fprintf(os.Stderr, "[nats-micro] WARN: failed to persist {{.GoName}} response to KV: %v\n", kvErr)
			}
		}
	}
	{{- end}}
	{{- end}}

	{{- /* Object Store persistence: auto-persist response to Object Store */}}
	{{- if $endpointOpts.ObjectStore}}
	{{- if not $endpointOpts.ObjectStore.ClientOnly}}
	// Auto-persist response to Object Store (bucket: "{{$endpointOpts.ObjectStore.Bucket}}")
	if h.js != nil {
		objKey := {{ResolveKeyTemplateGo $endpointOpts.ObjectStore.KeyTemplate .}}
		obj, objErr := h.js.ObjectStore(ctx, "{{$endpointOpts.ObjectStore.Bucket}}")
		if objErr != nil {
			fmt.Fprintf(os.Stderr, "[nats-micro] WARN: Object Store bucket \"{{$endpointOpts.ObjectStore.Bucket}}\" not available for {{.GoName}}: %v\n", objErr)
		} else {
			if _, objErr = obj.PutBytes(ctx, objKey, data); objErr != nil {
				fmt.Fprintf(os.Stderr, "[nats-micro] WARN: failed to persist {{.GoName}} response to Object Store: %v\n", objErr)
			}
		}
	}
	{{- end}}
	{{- end}}

	if len(outgoingHeaders) > 0 {
		// Send response with headers using micro.WithHeaders
		// Convert nats.Header to micro.Headers (they are the same underlying type)
		if err := req.Respond(data, micro.WithHeaders(micro.Headers(outgoingHeaders))); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for {{.GoName}}: %v\n", err)
		}
	} else {
		// Send response without headers
		if err := req.Respond(data); err != nil {
			fmt.Fprintf(os.Stderr, "failed to send response for {{.GoName}}: %v\n", err)
		}
	}
}
{{- end}}{{/* end IsUnary */}}

{{- if IsServerStreaming .}}
{{- if not (IsClientStreaming .)}}
// {{.GoName}} handles server-side streaming RPC.
// Client sends a single request; server streams back multiple responses.
func (h *{{ToLowerFirst $.Service.GoName}}Handlers) {{.GoName}}(req micro.Request) {
	// Determine effective timeout: endpoint-specific timeout overrides service timeout
	timeout := h.serviceTimeout
	{{- if gt $endpointOpts.Timeout.Nanoseconds 0}}
	timeout = {{$endpointOpts.Timeout.Seconds}} * time.Second // Endpoint-specific timeout
	{{- end}}

	ctx := context.Background()
	var cancel context.CancelFunc
	if timeout > 0 {
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}

	if req.Headers() != nil {
		ctx = WithIncomingHeaders(ctx, req.Headers())
	}

	var msg {{.Input.GoIdent.GoName}}
	if h.useJSON {
		if err := protojson.Unmarshal(req.Data(), &msg); err != nil {
			req.Error({{$.Service.GoName}}ErrCodeInvalidArgument, fmt.Sprintf("failed to decode request: %v", err), nil)
			return
		}
	} else {
		if err := proto.Unmarshal(req.Data(), &msg); err != nil {
			req.Error({{$.Service.GoName}}ErrCodeInvalidArgument, fmt.Sprintf("failed to decode request: %v", err), nil)
			return
		}
	}

	// Get the client's reply subject from the NATS request
	var replySubject string
	if req.Headers() != nil {
		replySubject = req.Headers().Get("Reply-To")
	}
	if replySubject == "" {
		// Fall back to using the NATS request reply subject
		// We need to signal to the client that we're starting a stream
		// First, acknowledge the request by responding with the stream inbox
		inbox := nats.NewInbox()
		replySubject = inbox
		ackHeader := nats.Header{}
		ackHeader.Set(natsStreamInboxHeader, inbox)
		req.Respond(nil, micro.WithHeaders(micro.Headers(ackHeader)))
	}

	sender := newServerStreamSender(h.nc, replySubject)
	stream := &{{$.Service.GoName}}_{{.GoName}}_Stream{
		sender:  sender,
		useJSON: h.useJSON,
	}

	if err := h.impl.{{.GoName}}(ctx, &msg, stream); err != nil {
		sender.CloseWithError({{$.Service.GoName}}ErrCodeInternal, err.Error())
		return
	}
	sender.Close()
}
{{- end}}
{{- end}}

{{- if IsClientStreaming .}}
{{- if not (IsServerStreaming .)}}
// {{.GoName}} handles client-side streaming RPC.
// Client streams multiple requests; server responds once.
func (h *{{ToLowerFirst $.Service.GoName}}Handlers) {{.GoName}}(req micro.Request) {
	// Determine effective timeout: endpoint-specific timeout overrides service timeout
	timeout := h.serviceTimeout
	{{- if gt $endpointOpts.Timeout.Nanoseconds 0}}
	timeout = {{$endpointOpts.Timeout.Seconds}} * time.Second // Endpoint-specific timeout
	{{- end}}

	ctx := context.Background()
	var cancel context.CancelFunc
	if timeout > 0 {
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}

	if req.Headers() != nil {
		ctx = WithIncomingHeaders(ctx, req.Headers())
	}

	// Create an inbox for receiving the client's stream messages
	inbox := nats.NewInbox()
	receiver, err := newClientStreamReceiver(h.nc, inbox, false)
	if err != nil {
		req.Error({{$.Service.GoName}}ErrCodeInternal, fmt.Sprintf("failed to setup stream: %v", err), nil)
		return
	}
	defer receiver.Close()

	// Tell the client where to send stream messages
	ackHeader := nats.Header{}
	ackHeader.Set(natsStreamInboxHeader, inbox)
	req.Respond(nil, micro.WithHeaders(micro.Headers(ackHeader)))

	stream := &{{$.Service.GoName}}_{{.GoName}}_Stream{
		receiver: receiver,
		useJSON:  h.useJSON,
	}

	resp, err := h.impl.{{.GoName}}(ctx, stream)
	if err != nil {
		// Ack was already sent, so we can't use req.Error().
		// Publish the error back to the client's Reply-To inbox using the stream
		// error protocol, so the client doesn't hang waiting for a response.
		fmt.Fprintf(os.Stderr, "[nats-micro] ERROR: {{.GoName}} client stream handler failed: %v\n", err)
		var replySubject string
		if req.Headers() != nil {
			replySubject = req.Headers().Get("Reply-To")
		}
		if replySubject != "" {
			errMsg := &nats.Msg{
				Subject: replySubject,
				Header:  nats.Header{},
			}
			errMsg.Header.Set("Nats-Service-Error-Code", {{$.Service.GoName}}ErrCodeInternal)
			errMsg.Header.Set("Nats-Service-Error", err.Error())
			h.nc.PublishMsg(errMsg)
		}
		return
	}

	// Send final response back via the original reply subject
	var data []byte
	if h.useJSON {
		data, err = protojson.Marshal(resp)
	} else {
		data, err = proto.Marshal(resp)
	}
	if err != nil {
		fmt.Fprintf(os.Stderr, "[nats-micro] ERROR: failed to marshal {{.GoName}} response: %v\n", err)
		return
	}

	// Publish the final response to the client's reply inbox
	// The client will have subscribed for the reply
	var replySubject string
	if req.Headers() != nil {
		replySubject = req.Headers().Get("Reply-To")
	}
	if replySubject != "" {
		h.nc.Publish(replySubject, data)
	}
}
{{- end}}
{{- end}}

{{- if IsBidiStreaming .}}
// {{.GoName}} handles bidirectional streaming RPC.
// Both client and server can send and receive messages concurrently.
func (h *{{ToLowerFirst $.Service.GoName}}Handlers) {{.GoName}}(req micro.Request) {
	// Determine effective timeout: endpoint-specific timeout overrides service timeout
	timeout := h.serviceTimeout
	{{- if gt $endpointOpts.Timeout.Nanoseconds 0}}
	timeout = {{$endpointOpts.Timeout.Seconds}} * time.Second // Endpoint-specific timeout
	{{- end}}

	ctx := context.Background()
	var cancel context.CancelFunc
	if timeout > 0 {
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}

	if req.Headers() != nil {
		ctx = WithIncomingHeaders(ctx, req.Headers())
	}

	// Create inbox for receiving client stream messages
	serverInbox := nats.NewInbox()
	receiver, err := newClientStreamReceiver(h.nc, serverInbox, false)
	if err != nil {
		req.Error({{$.Service.GoName}}ErrCodeInternal, fmt.Sprintf("failed to setup stream: %v", err), nil)
		return
	}
	defer receiver.Close()

	// Get/create the reply subject for serverâ†’client messages
	var clientInbox string
	if req.Headers() != nil {
		clientInbox = req.Headers().Get("Reply-To")
	}
	if clientInbox == "" {
		clientInbox = nats.NewInbox()
	}

	// Tell the client where to send its stream messages and where we'll send ours
	ackHeader := nats.Header{}
	ackHeader.Set(natsStreamInboxHeader, serverInbox)
	req.Respond(nil, micro.WithHeaders(micro.Headers(ackHeader)))

	sender := newServerStreamSender(h.nc, clientInbox)
	stream := &{{$.Service.GoName}}_{{.GoName}}_Stream{
		sender:   sender,
		receiver: receiver,
		useJSON:  h.useJSON,
	}

	if err := h.impl.{{.GoName}}(ctx, stream); err != nil {
		sender.CloseWithError({{$.Service.GoName}}ErrCodeInternal, err.Error())
		return
	}
	sender.Close()
}
{{- end}}

{{end}}
{{end}}
