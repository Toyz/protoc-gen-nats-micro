{{- /* Service interface and registration function */ -}}
{{- if not .Options.SubjectPrefix }}
// WARNING: Service {{.Service.GoName}} is missing required option (nats.micro.service).subject_prefix
// The service will not function correctly without a subject prefix.

{{end -}}
// {{.Service.GoName}}Nats is the NATS service interface for {{.Service.GoName}}
type {{.Service.GoName}}Nats interface {
{{- range .Service.Methods}}
	{{.GoName}}(context.Context, *{{.Input.GoIdent.GoName}}) (*{{.Output.GoIdent.GoName}}, error)
{{- end}}
}

// Register{{.Service.GoName}}Handlers registers the service with NATS micro handlers
// Service: {{.Options.Name}} v{{.Options.Version}}
{{- if .Options.Description}}
// Description: {{.Options.Description}}
{{- end}}
// Subject prefix: {{.Options.SubjectPrefix}}
{{- if .Options.Metadata}}
// Metadata: {{range $key, $value := .Options.Metadata}}{{$key}}={{$value}} {{end}}
{{- end}}
// Configuration options: WithName(), WithVersion(), WithDescription(), WithSubjectPrefix(), WithTimeout()
// Metadata options: WithMetadata() (replace), WithAdditionalMetadata() (merge)
// Handler options: WithStatsHandler(), WithDoneHandler(), WithErrorHandler()
func Register{{.Service.GoName}}Handlers(nc *nats.Conn, impl {{.Service.GoName}}Nats, opts ...RegisterOption) (micro.Service, error) {
	cfg := &registerConfig{
		name:          "{{.Options.Name}}",
		version:       "{{.Options.Version}}",
		description:   "{{.Options.Description}}",
		subjectPrefix: "{{.Options.SubjectPrefix}}",
		timeout:       time.Duration({{.Options.Timeout.Nanoseconds}}), // Service-level timeout (0 = no timeout)
		metadata:      map[string]string{
{{- range $key, $value := .Options.Metadata}}
			"{{$key}}": "{{$value}}",
{{- end}}
		},
	}
	for _, opt := range opts {
		opt(cfg)
	}

	svc, err := micro.AddService(nc, micro.Config{
		Name:         cfg.name,
		Version:      cfg.version,
		Metadata:     cfg.metadata,
		Description:  cfg.description,
		StatsHandler: cfg.statsHandler,
		DoneHandler:  cfg.doneHandler,
		ErrorHandler: cfg.errorHandler,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to add service: %w", err)
	}

	handlers := &{{ToLowerFirst .Service.GoName}}Handlers{
		impl:    impl,
		timeout: cfg.timeout,
	}

	// Map of endpoint names to their handlers
	endpoints := map[string]micro.Handler{
{{range .Service.Methods -}}
		"{{ToSnakeCase .GoName}}": micro.HandlerFunc(handlers.{{.GoName}}),
{{end -}}
	}

	// Use interface to handle both Service and Group
	type endpointAdder interface {
		AddEndpoint(string, micro.Handler, ...micro.EndpointOpt) error
	}

	var adder endpointAdder = svc
	if cfg.subjectPrefix != "" {
		adder = svc.AddGroup(cfg.subjectPrefix)
	}

	// Register all endpoints
	for name, handler := range endpoints {
		if err := adder.AddEndpoint(name, handler); err != nil {
			return nil, fmt.Errorf("failed to add endpoint %s: %w", name, err)
		}
	}

	return svc, nil
}

// {{ToLowerFirst .Service.GoName}}Handlers wraps the service implementation with NATS handlers
type {{ToLowerFirst .Service.GoName}}Handlers struct {
	impl    {{.Service.GoName}}Nats
	timeout time.Duration
}

{{range .Service.Methods -}}
func (h *{{ToLowerFirst $.Service.GoName}}Handlers) {{.GoName}}(req micro.Request) {
	// Create context with timeout if configured, otherwise use background context
	ctx := context.Background()
	var cancel context.CancelFunc
	if h.timeout > 0 {
		ctx, cancel = context.WithTimeout(ctx, h.timeout)
		defer cancel()
	}

	var msg {{.Input.GoIdent.GoName}}
	if err := proto.Unmarshal(req.Data(), &msg); err != nil {
		req.Error({{$.Service.GoName}}ErrCodeInvalidArgument, fmt.Sprintf("failed to decode request: %v", err), nil)
		return
	}

	resp, err := h.impl.{{.GoName}}(ctx, &msg)
	if err != nil {
		// Check if error implements custom status code interface
		code := {{$.Service.GoName}}ErrCodeInternal
		message := fmt.Sprintf("{{.GoName}} failed: %v", err)
		var data []byte

		if statusCoder, ok := err.(NatsStatusCoder); ok {
			code = statusCoder.NatsErrorCode()
		}
		if messager, ok := err.(NatsErrorMessager); ok {
			message = messager.NatsErrorMessage()
		}
		if dataProvider, ok := err.(NatsErrorDataProvider); ok {
			data = dataProvider.NatsErrorData()
		}

		req.Error(code, message, data)
		return
	}

	data, err := proto.Marshal(resp)
	if err != nil {
		req.Error({{$.Service.GoName}}ErrCodeInternal, fmt.Sprintf("failed to encode response: %v", err), nil)
		return
	}

	if err := req.Respond(data); err != nil {
		// Log response send failure (client may have disconnected)
		fmt.Fprintf(os.Stderr, "failed to send response for {{.GoName}}: %v\n", err)
	}
}
{{end}}


type registerConfig struct {
	name          string
	version       string
	description   string
	subjectPrefix string
	timeout       time.Duration
	metadata      map[string]string
	statsHandler  micro.StatsHandler
	doneHandler   micro.DoneHandler
	errorHandler  micro.ErrHandler
}

// RegisterOption configures the service registration
type RegisterOption func(*registerConfig)

// WithName overrides the service name from the proto definition
func WithName(name string) RegisterOption {
	return func(c *registerConfig) { c.name = name }
}

// WithVersion overrides the service version from the proto definition
func WithVersion(version string) RegisterOption {
	return func(c *registerConfig) { c.version = version }
}

// WithDescription overrides the service description from the proto definition
func WithDescription(desc string) RegisterOption {
	return func(c *registerConfig) { c.description = desc }
}

// WithSubjectPrefix overrides the subject prefix from the proto definition
func WithSubjectPrefix(prefix string) RegisterOption {
	return func(c *registerConfig) { c.subjectPrefix = prefix }
}

// WithTimeout sets the default timeout for all service methods.
// This overrides the timeout configured in the proto definition.
// Use 0 for no timeout (context.Background).
func WithTimeout(timeout time.Duration) RegisterOption {
	return func(c *registerConfig) { c.timeout = timeout }
}

// WithMetadata replaces all service metadata.
// This completely overrides metadata defined in the proto definition.
// Use WithAdditionalMetadata to merge with proto metadata instead.
func WithMetadata(metadata map[string]string) RegisterOption {
	return func(c *registerConfig) { c.metadata = metadata }
}

// WithAdditionalMetadata adds or updates metadata entries.
// This merges with metadata defined in the proto definition.
// Duplicate keys will override proto values.
func WithAdditionalMetadata(metadata map[string]string) RegisterOption {
	return func(c *registerConfig) {
		for k, v := range metadata {
			c.metadata[k] = v
		}
	}
}

// WithStatsHandler sets a callback for service statistics.
// The handler is called periodically with endpoint stats including
// request counts, error counts, and processing times.
func WithStatsHandler(handler micro.StatsHandler) RegisterOption {
	return func(c *registerConfig) { c.statsHandler = handler }
}

// WithDoneHandler sets a callback invoked when the service stops
func WithDoneHandler(handler micro.DoneHandler) RegisterOption {
	return func(c *registerConfig) { c.doneHandler = handler }
}

// WithErrorHandler sets a callback for handling service-level errors
func WithErrorHandler(handler micro.ErrHandler) RegisterOption {
	return func(c *registerConfig) { c.errorHandler = handler }
}
