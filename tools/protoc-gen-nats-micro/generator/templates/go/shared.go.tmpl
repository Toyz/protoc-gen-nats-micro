{{- /* Shared types and functions for all services in a proto file */ -}}
// Common error codes used across all NATS microservices
const (
	ErrCodeInvalidArgument  = "INVALID_ARGUMENT"
	ErrCodeNotFound         = "NOT_FOUND"
	ErrCodeAlreadyExists    = "ALREADY_EXISTS"
	ErrCodePermissionDenied = "PERMISSION_DENIED"
	ErrCodeUnauthenticated  = "UNAUTHENTICATED"
	ErrCodeInternal         = "INTERNAL"
	ErrCodeUnavailable      = "UNAVAILABLE"
)

// Context keys for NATS headers
type contextKey int

const (
	incomingHeadersKey contextKey = iota
	outgoingHeadersKey
	responseHeadersKey
)

// IncomingHeaders extracts incoming NATS headers from the context (server-side)
// Returns nil if no headers are present
func IncomingHeaders(ctx context.Context) micro.Headers {
	if headers, ok := ctx.Value(incomingHeadersKey).(micro.Headers); ok {
		return headers
	}
	return nil
}

// OutgoingHeaders extracts outgoing NATS headers from the context (client-side)
// Returns nil if no headers are present
func OutgoingHeaders(ctx context.Context) nats.Header {
	if headers, ok := ctx.Value(outgoingHeadersKey).(nats.Header); ok {
		return headers
	}
	return nil
}

// WithIncomingHeaders adds incoming NATS headers to the context (used internally by server)
func WithIncomingHeaders(ctx context.Context, headers micro.Headers) context.Context {
	return context.WithValue(ctx, incomingHeadersKey, headers)
}

// WithOutgoingHeaders adds outgoing NATS headers to the context (used by client)
// Example: ctx := WithOutgoingHeaders(ctx, nats.Header{"Authorization": []string{"Bearer token"}})
func WithOutgoingHeaders(ctx context.Context, headers nats.Header) context.Context {
	return context.WithValue(ctx, outgoingHeadersKey, headers)
}

// ResponseHeaders extracts response headers from the context (client-side, after call)
// Returns nil if no response headers are present
func ResponseHeaders(ctx context.Context) nats.Header {
	// Response headers are stored as a pointer in the context
	// The invoker updates the pointer, allowing interceptors to read the headers
	if headersPtr, ok := ctx.Value(responseHeadersKey).(*nats.Header); ok && headersPtr != nil {
		return *headersPtr
	}
	return nil
}

// WithResponseHeaders adds response headers to the context (used internally by client)
func WithResponseHeaders(ctx context.Context, headers nats.Header) context.Context {
	return context.WithValue(ctx, responseHeadersKey, headers)
}

// SetResponseHeaders allows server interceptors/handlers to add response headers
// These will be sent back to the client with the response
// Example: SetResponseHeaders(ctx, nats.Header{"X-Server-Version": []string{"1.0.0"}})
// Note: This modifies a mutable pointer stored in the context, so you don't need to capture the return value
func SetResponseHeaders(ctx context.Context, headers nats.Header) {
	// Get the pointer to response headers from context and update it
	if headersPtr, ok := ctx.Value(outgoingHeadersKey).(*nats.Header); ok && headersPtr != nil {
		*headersPtr = headers
	}
}

// UnaryServerInfo contains information about a unary RPC
type UnaryServerInfo struct {
	Service     string // Service name
	Method      string // Method name
	Subject     string // NATS subject
}

// UnaryHandler is the actual handler function to be called
type UnaryHandler func(ctx context.Context, req interface{}) (interface{}, error)

// UnaryServerInterceptor is middleware that can intercept unary RPC calls on the server
// It receives the context, request, RPC info, and the handler to call.
// The interceptor can inspect/modify the request, handle auth, logging, etc.
// It must call handler(ctx, req) to continue the chain or return early.
type UnaryServerInterceptor func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (interface{}, error)

// UnaryInvoker is called by a UnaryClientInterceptor to complete the RPC
type UnaryInvoker func(ctx context.Context, method string, req, reply interface{}) error

// UnaryClientInterceptor is middleware that can intercept unary RPC calls on the client
// It receives the context, method name, request, reply, and invoker.
// The interceptor can inspect/modify requests, handle retries, logging, etc.
// It must call invoker(ctx, method, req, reply) to continue the chain.
type UnaryClientInterceptor func(ctx context.Context, method string, req, reply interface{}, invoker UnaryInvoker) error

// registerConfig holds configuration for service registration
type registerConfig struct {
	name               string
	version            string
	description        string
	subjectPrefix      string
	timeout            time.Duration
	metadata           map[string]string
	statsHandler       micro.StatsHandler
	doneHandler        micro.DoneHandler
	errorHandler       micro.ErrHandler
	serverInterceptors []UnaryServerInterceptor
}

// RegisterOption configures the service registration
type RegisterOption func(*registerConfig)

// WithName overrides the service name from the proto definition
func WithName(name string) RegisterOption {
	return func(c *registerConfig) { c.name = name }
}

// WithVersion overrides the service version from the proto definition
func WithVersion(version string) RegisterOption {
	return func(c *registerConfig) { c.version = version }
}

// WithDescription overrides the service description from the proto definition
func WithDescription(desc string) RegisterOption {
	return func(c *registerConfig) { c.description = desc }
}

// WithSubjectPrefix overrides the subject prefix from the proto definition
func WithSubjectPrefix(prefix string) RegisterOption {
	return func(c *registerConfig) { c.subjectPrefix = prefix }
}

// WithTimeout sets the default timeout for all service methods.
// This overrides the timeout configured in the proto definition.
// Use 0 for no timeout (context.Background).
func WithTimeout(timeout time.Duration) RegisterOption {
	return func(c *registerConfig) { c.timeout = timeout }
}

// WithMetadata replaces all service metadata.
// This completely overrides metadata defined in the proto definition.
// Use WithAdditionalMetadata to merge with proto metadata instead.
func WithMetadata(metadata map[string]string) RegisterOption {
	return func(c *registerConfig) { c.metadata = metadata }
}

// WithAdditionalMetadata adds or updates metadata entries.
// This merges with metadata defined in the proto definition.
// Duplicate keys will override proto values.
func WithAdditionalMetadata(metadata map[string]string) RegisterOption {
	return func(c *registerConfig) {
		for k, v := range metadata {
			c.metadata[k] = v
		}
	}
}

// WithStatsHandler sets a callback for service statistics.
// The handler is called periodically with endpoint stats including
// request counts, error counts, and processing times.
func WithStatsHandler(handler micro.StatsHandler) RegisterOption {
	return func(c *registerConfig) { c.statsHandler = handler }
}

// WithDoneHandler sets a callback invoked when the service stops
func WithDoneHandler(handler micro.DoneHandler) RegisterOption {
	return func(c *registerConfig) { c.doneHandler = handler }
}

// WithErrorHandler sets a callback for handling service-level errors
func WithErrorHandler(handler micro.ErrHandler) RegisterOption {
	return func(c *registerConfig) { c.errorHandler = handler }
}

// WithServerInterceptor adds a unary server interceptor to the service.
// Interceptors are executed in the order they are added.
// Use for cross-cutting concerns like logging, auth, metrics, tracing.
func WithServerInterceptor(interceptor UnaryServerInterceptor) RegisterOption {
	return func(c *registerConfig) {
		c.serverInterceptors = append(c.serverInterceptors, interceptor)
	}
}

// chainUnaryServerInterceptors creates a single interceptor that chains multiple interceptors
func chainUnaryServerInterceptors(interceptors []UnaryServerInterceptor) UnaryServerInterceptor {
	n := len(interceptors)
	
	if n == 0 {
		return nil
	}
	
	if n == 1 {
		return interceptors[0]
	}
	
	return func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (interface{}, error) {
		// Build chain from last to first
		chainedHandler := handler
		for i := n - 1; i >= 0; i-- {
			interceptor := interceptors[i]
			nextHandler := chainedHandler
			chainedHandler = func(currentCtx context.Context, currentReq interface{}) (interface{}, error) {
				return interceptor(currentCtx, currentReq, info, nextHandler)
			}
		}
		return chainedHandler(ctx, req)
	}
}

// natsClientConfig holds configuration for NATS clients
type natsClientConfig struct {
	subjectPrefix      string
	clientInterceptors []UnaryClientInterceptor
}

// NatsClientOption is a generic client configuration option
// It uses an interface to allow configuration of any client type
type NatsClientOption interface {
	applyNatsClientOption(*natsClientConfig)
}

// natsClientOptionFunc is a function adapter for NatsClientOption
type natsClientOptionFunc func(*natsClientConfig)

func (f natsClientOptionFunc) applyNatsClientOption(c *natsClientConfig) {
	f(c)
}

// WithNatsClientSubjectPrefix overrides the subject prefix for the client.
// By default, the prefix from the proto definition is used.
func WithNatsClientSubjectPrefix(prefix string) NatsClientOption {
	return natsClientOptionFunc(func(c *natsClientConfig) {
		c.subjectPrefix = prefix
	})
}

// WithClientInterceptor adds a unary client interceptor.
// Interceptors are executed in the order they are added.
// Use for cross-cutting concerns like logging, retries, circuit breaking.
func WithClientInterceptor(interceptor UnaryClientInterceptor) NatsClientOption {
	return natsClientOptionFunc(func(c *natsClientConfig) {
		c.clientInterceptors = append(c.clientInterceptors, interceptor)
	})
}

// chainUnaryClientInterceptors creates a single interceptor that chains multiple interceptors
func chainUnaryClientInterceptors(interceptors []UnaryClientInterceptor) UnaryClientInterceptor {
	n := len(interceptors)
	
	if n == 0 {
		return nil
	}
	
	if n == 1 {
		return interceptors[0]
	}
	
	return func(ctx context.Context, method string, req, reply interface{}, invoker UnaryInvoker) error {
		// Build chain from last to first
		chainedInvoker := invoker
		for i := n - 1; i >= 0; i-- {
			interceptor := interceptors[i]
			nextInvoker := chainedInvoker
			chainedInvoker = func(currentCtx context.Context, currentMethod string, currentReq, currentReply interface{}) error {
				return interceptor(currentCtx, currentMethod, currentReq, currentReply, nextInvoker)
			}
		}
		return chainedInvoker(ctx, method, req, reply)
	}
}

