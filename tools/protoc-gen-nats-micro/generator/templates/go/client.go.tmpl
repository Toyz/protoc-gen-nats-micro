{{- /* Client implementation */ -}}
// {{.Service.GoName}}NatsClientInterface is the interface for the NATS client
// This interface allows for easier dependency injection and testing
type {{.Service.GoName}}NatsClientInterface interface {
{{- range .Service.Methods}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
  {{.GoName}}(context.Context, *{{.Input.GoIdent.GoName}}) (*{{.Output.GoIdent.GoName}}, error)
{{- if $endpointOpts.KVStore}}
  Get{{.GoName}}FromKV(ctx context.Context, key string) (*{{.Output.GoIdent.GoName}}, error)
{{- end}}
{{- if $endpointOpts.ObjectStore}}
  Get{{.GoName}}FromObjectStore(ctx context.Context, key string) (*{{.Output.GoIdent.GoName}}, error)
{{- end}}
{{- end}}
{{- end}}
  Endpoints() []{{.Service.GoName}}EndpointInfo
}

// {{.Service.GoName}}NatsClient is the concrete implementation of {{.Service.GoName}}NatsClientInterface
type {{.Service.GoName}}NatsClient struct {
  nc            *nats.Conn
  subjectPrefix string
  useJSON       bool                       // Use JSON encoding instead of binary protobuf
  interceptor   UnaryClientInterceptor     // Chained interceptors
  js            jetstream.JetStream        // Optional JetStream for KV/ObjectStore reads
}

// New{{.Service.GoName}}NatsClient creates a new NATS client for {{.Service.GoName}}.
// The client sends requests over NATS using protobuf serialization (or JSON if configured).
func New{{.Service.GoName}}NatsClient(nc *nats.Conn, opts ...NatsClientOption) {{.Service.GoName}}NatsClientInterface {
  cfg := &natsClientConfig{
    subjectPrefix: "{{.Options.SubjectPrefix}}",
  }
  for _, opt := range opts {
    opt.applyNatsClientOption(cfg)
  }
  
  // Chain client interceptors
  var chainedInterceptor UnaryClientInterceptor
  if len(cfg.clientInterceptors) > 0 {
    chainedInterceptor = chainUnaryClientInterceptors(cfg.clientInterceptors)
  }
  
  c := &{{.Service.GoName}}NatsClient{
    nc:            nc,
    subjectPrefix: cfg.subjectPrefix,
    useJSON:       {{.Options.UseJSON}},
    interceptor:   chainedInterceptor,
    js:            cfg.js,
  }
  return c
}

{{range .Service.Methods -}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
// {{.GoName}} sends a {{.GoName}} request to the service via NATS.
// Returns an error if the request fails or the service returns an error.
func (c *{{$.Service.GoName}}NatsClient) {{.GoName}}(ctx context.Context, req *{{.Input.GoIdent.GoName}}) (*{{.Output.GoIdent.GoName}}, error) {
  method := "{{.GoName}}"
  
  // Pointer to store response headers - stored in context so invoker can update it
  responseHeadersPtr := &nats.Header{}
  
  // Add the response headers pointer to context so invoker can populate it
  // Interceptors can then read the headers from the same context
  ctx = context.WithValue(ctx, responseHeadersKey, responseHeadersPtr)
  
  // Define the invoker function that performs the actual NATS call
  invoker := func(invokerCtx context.Context, method string, request, reply interface{}) error {
    subject := c.subjectPrefix + ".{{ToSnakeCase .GoName}}"
    
    // Marshal request
    typedReq, ok := request.(*{{.Input.GoIdent.GoName}})
    if !ok {
      return fmt.Errorf("invalid request type")
    }
    
    var data []byte
    var err error
    if c.useJSON {
      data, err = protojson.Marshal(typedReq)
    } else {
      data, err = proto.Marshal(typedReq)
    }
    if err != nil {
      return err
    }

    // Extract outgoing headers from context and attach to NATS message
    var msg *nats.Msg
    if headers := OutgoingHeaders(invokerCtx); headers != nil {
      msg, err = c.nc.RequestMsgWithContext(invokerCtx, &nats.Msg{
        Subject: subject,
        Data:    data,
        Header:  headers,
      })
    } else {
      msg, err = c.nc.RequestWithContext(invokerCtx, subject, data)
    }
    if err != nil {
      return err
    }

		// Store response headers in the pointer from context
		if msg.Header != nil && len(msg.Header) > 0 {
			if headersPtr, ok := invokerCtx.Value(responseHeadersKey).(*nats.Header); ok && headersPtr != nil {
				*headersPtr = msg.Header
			}
		}    // Check if this is an error response from the service
    if msg.Header.Get("Status") != "" {
      code := msg.Header.Get("Status")
      description := msg.Header.Get("Description")
      return &{{$.Service.GoName}}Error{
        Code:    code,
        Method:  method,
        Message: description,
      }
    }

    // Unmarshal response
    typedReply, ok := reply.(*{{.Output.GoIdent.GoName}})
    if !ok {
      return fmt.Errorf("invalid reply type")
    }
    
    if c.useJSON {
      err = protojson.Unmarshal(msg.Data, typedReply)
    } else {
      err = proto.Unmarshal(msg.Data, typedReply)
    }
    return err
  }

  var resp {{.Output.GoIdent.GoName}}
  
  // Execute through interceptor chain if configured
  var err error
  if c.interceptor != nil {
    err = c.interceptor(ctx, method, req, &resp, invoker)
  } else {
    err = invoker(ctx, method, req, &resp)
  }
  
  if err != nil {
    return nil, err
  }

  return &resp, nil
}

{{- if $endpointOpts.KVStore}}

// Get{{.GoName}}FromKV reads a {{.GoName}} response directly from the KV Store.
// The key should match the key_template pattern used when the response was persisted.
// Requires the client to be created with WithNatsClientJetStream.
func (c *{{$.Service.GoName}}NatsClient) Get{{.GoName}}FromKV(ctx context.Context, key string) (*{{.Output.GoIdent.GoName}}, error) {
  if c.js == nil {
    return nil, errors.New("JetStream not configured; use WithNatsClientJetStream to enable KV reads")
  }
  kv, err := c.js.KeyValue(ctx, "{{$endpointOpts.KVStore.Bucket}}")
  if err != nil {
    return nil, fmt.Errorf("failed to open KV bucket \"{{$endpointOpts.KVStore.Bucket}}\": %w", err)
  }
  entry, err := kv.Get(ctx, key)
  if err != nil {
    return nil, fmt.Errorf("KV get failed for key %q: %w", key, err)
  }
  var resp {{.Output.GoIdent.GoName}}
  if c.useJSON {
    if err := protojson.Unmarshal(entry.Value(), &resp); err != nil {
      return nil, fmt.Errorf("failed to decode KV value: %w", err)
    }
  } else {
    if err := proto.Unmarshal(entry.Value(), &resp); err != nil {
      return nil, fmt.Errorf("failed to decode KV value: %w", err)
    }
  }
  return &resp, nil
}
{{- end}}

{{- if $endpointOpts.ObjectStore}}

// Get{{.GoName}}FromObjectStore reads a {{.GoName}} response directly from the Object Store.
// The key should match the key_template pattern used when the response was persisted.
// Requires the client to be created with WithNatsClientJetStream.
func (c *{{$.Service.GoName}}NatsClient) Get{{.GoName}}FromObjectStore(ctx context.Context, key string) (*{{.Output.GoIdent.GoName}}, error) {
  if c.js == nil {
    return nil, errors.New("JetStream not configured; use WithNatsClientJetStream to enable Object Store reads")
  }
  obj, err := c.js.ObjectStore(ctx, "{{$endpointOpts.ObjectStore.Bucket}}")
  if err != nil {
    return nil, fmt.Errorf("failed to open Object Store bucket \"{{$endpointOpts.ObjectStore.Bucket}}\": %w", err)
  }
  data, err := obj.GetBytes(ctx, key)
  if err != nil {
    return nil, fmt.Errorf("Object Store get failed for key %q: %w", key, err)
  }
  var resp {{.Output.GoIdent.GoName}}
  if c.useJSON {
    if err := protojson.Unmarshal(data, &resp); err != nil {
      return nil, fmt.Errorf("failed to decode Object Store value: %w", err)
    }
  } else {
    if err := proto.Unmarshal(data, &resp); err != nil {
      return nil, fmt.Errorf("failed to decode Object Store value: %w", err)
    }
  }
  return &resp, nil
}
{{- end}}

{{end -}}
{{end -}}
// Endpoints returns information about all service endpoints this client can call.
// This is useful for debugging, monitoring, and introspection.
func (c *{{.Service.GoName}}NatsClient) Endpoints() []{{.Service.GoName}}EndpointInfo {
  return []{{.Service.GoName}}EndpointInfo{
{{- range .Service.Methods}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
    {Name: "{{.GoName}}", Subject: c.subjectPrefix + ".{{ToSnakeCase .GoName}}"},
{{- end}}
{{- end}}
  }
}

