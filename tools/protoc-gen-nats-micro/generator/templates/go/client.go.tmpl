{{- /* Client implementation */ -}}
// {{.Service.GoName}}NatsClientInterface is the interface for the NATS client
// This interface allows for easier dependency injection and testing
type {{.Service.GoName}}NatsClientInterface interface {
{{- range .Service.Methods}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
{{- if IsUnary .}}
  {{.GoName}}(context.Context, *{{.Input.GoIdent.GoName}}) (*{{.Output.GoIdent.GoName}}, error)
{{- if $endpointOpts.KVStore}}
  Get{{.GoName}}FromKV(ctx context.Context, key string) (*{{.Output.GoIdent.GoName}}, error)
  Put{{.GoName}}ToKV(ctx context.Context, key string, val *{{.Output.GoIdent.GoName}}) error
{{- end}}
{{- if $endpointOpts.ObjectStore}}
  Get{{.GoName}}FromObjectStore(ctx context.Context, key string) (*{{.Output.GoIdent.GoName}}, error)
  Put{{.GoName}}ToObjectStore(ctx context.Context, key string, val *{{.Output.GoIdent.GoName}}) error
{{- end}}
{{- else if IsServerStreaming .}}
{{- if not (IsClientStreaming .)}}
  {{.GoName}}(ctx context.Context, req *{{.Input.GoIdent.GoName}}) (*{{$.Service.GoName}}_{{.GoName}}_ClientStream, error)
{{- end}}
{{- end}}
{{- if IsBidiStreaming .}}
  {{.GoName}}(ctx context.Context) (*{{$.Service.GoName}}_{{.GoName}}_ClientStream, error)
{{- end}}
{{- if IsClientStreaming .}}
{{- if not (IsServerStreaming .)}}
  {{.GoName}}(ctx context.Context) (*{{$.Service.GoName}}_{{.GoName}}_ClientStream, error)
{{- end}}
{{- end}}
{{- end}}
{{- end}}
  Endpoints() []{{.Service.GoName}}EndpointInfo
}

// {{.Service.GoName}}NatsClient is the concrete implementation of {{.Service.GoName}}NatsClientInterface
type {{.Service.GoName}}NatsClient struct {
  nc            *nats.Conn
  subjectPrefix string
  useJSON       bool                       // Use JSON encoding instead of binary protobuf
  interceptor   UnaryClientInterceptor     // Chained interceptors
  js            jetstream.JetStream        // Optional JetStream for KV/ObjectStore reads
}

// New{{.Service.GoName}}NatsClient creates a new NATS client for {{.Service.GoName}}.
// The client sends requests over NATS using protobuf serialization (or JSON if configured).
func New{{.Service.GoName}}NatsClient(nc *nats.Conn, opts ...NatsClientOption) {{.Service.GoName}}NatsClientInterface {
  cfg := &natsClientConfig{
    subjectPrefix: "{{.Options.SubjectPrefix}}",
  }
  for _, opt := range opts {
    opt.applyNatsClientOption(cfg)
  }
  
  // Chain client interceptors
  var chainedInterceptor UnaryClientInterceptor
  if len(cfg.clientInterceptors) > 0 {
    chainedInterceptor = chainUnaryClientInterceptors(cfg.clientInterceptors)
  }
  
  c := &{{.Service.GoName}}NatsClient{
    nc:            nc,
    subjectPrefix: cfg.subjectPrefix,
    useJSON:       {{.Options.UseJSON}},
    interceptor:   chainedInterceptor,
    js:            cfg.js,
  }
  return c
}

{{range .Service.Methods -}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
{{- if IsUnary .}}
// {{.GoName}} sends a {{.GoName}} request to the service via NATS.
// Returns an error if the request fails or the service returns an error.
func (c *{{$.Service.GoName}}NatsClient) {{.GoName}}(ctx context.Context, req *{{.Input.GoIdent.GoName}}) (*{{.Output.GoIdent.GoName}}, error) {
  method := "{{.GoName}}"
  
  // Pointer to store response headers - stored in context so invoker can update it
  responseHeadersPtr := &nats.Header{}
  
  // Add the response headers pointer to context so invoker can populate it
  // Interceptors can then read the headers from the same context
  ctx = context.WithValue(ctx, responseHeadersKey, responseHeadersPtr)
  
  // Define the invoker function that performs the actual NATS call
  invoker := func(invokerCtx context.Context, method string, request, reply interface{}) error {
    subject := c.subjectPrefix + ".{{ToSnakeCase .GoName}}"
    
    // Marshal request
    typedReq, ok := request.(*{{.Input.GoIdent.GoName}})
    if !ok {
      return fmt.Errorf("invalid request type")
    }
    
    var data []byte
    var err error
    if c.useJSON {
      data, err = protojson.Marshal(typedReq)
    } else {
      data, err = proto.Marshal(typedReq)
    }
    if err != nil {
      return err
    }

    // Extract outgoing headers from context and attach to NATS message
    var msg *nats.Msg
    if headers := OutgoingHeaders(invokerCtx); headers != nil {
      msg, err = c.nc.RequestMsgWithContext(invokerCtx, &nats.Msg{
        Subject: subject,
        Data:    data,
        Header:  headers,
      })
    } else {
      msg, err = c.nc.RequestWithContext(invokerCtx, subject, data)
    }
    if err != nil {
      return err
    }

		// Store response headers in the pointer from context
		if msg.Header != nil && len(msg.Header) > 0 {
			if headersPtr, ok := invokerCtx.Value(responseHeadersKey).(*nats.Header); ok && headersPtr != nil {
				*headersPtr = msg.Header
			}
		}    // Check if this is an error response from the service (NATS micro headers)
    if msg.Header.Get("Nats-Service-Error-Code") != "" {
      code := msg.Header.Get("Nats-Service-Error-Code")
      description := msg.Header.Get("Nats-Service-Error")
      return &{{$.Service.GoName}}Error{
        Code:    code,
        Method:  method,
        Message: description,
      }
    }

    // Unmarshal response
    typedReply, ok := reply.(*{{.Output.GoIdent.GoName}})
    if !ok {
      return fmt.Errorf("invalid reply type")
    }
    
    if c.useJSON {
      err = protojson.Unmarshal(msg.Data, typedReply)
    } else {
      err = proto.Unmarshal(msg.Data, typedReply)
    }
    return err
  }

  var resp {{.Output.GoIdent.GoName}}
  
  // Execute through interceptor chain if configured
  var err error
  if c.interceptor != nil {
    err = c.interceptor(ctx, method, req, &resp, invoker)
  } else {
    err = invoker(ctx, method, req, &resp)
  }
  
  if err != nil {
    return nil, err
  }

  return &resp, nil
}

{{- if $endpointOpts.KVStore}}

// Get{{.GoName}}FromKV reads a {{.GoName}} response directly from the KV Store.
// The key should match the key_template pattern used when the response was persisted.
// Requires the client to be created with WithNatsClientJetStream.
func (c *{{$.Service.GoName}}NatsClient) Get{{.GoName}}FromKV(ctx context.Context, key string) (*{{.Output.GoIdent.GoName}}, error) {
  if c.js == nil {
    return nil, errors.New("JetStream not configured; use WithNatsClientJetStream to enable KV reads")
  }
  kv, err := c.js.KeyValue(ctx, "{{$endpointOpts.KVStore.Bucket}}")
  if err != nil {
    return nil, fmt.Errorf("failed to open KV bucket \"{{$endpointOpts.KVStore.Bucket}}\": %w", err)
  }
  entry, err := kv.Get(ctx, key)
  if err != nil {
    return nil, fmt.Errorf("KV get failed for key %q: %w", key, err)
  }
  var resp {{.Output.GoIdent.GoName}}
  if c.useJSON {
    if err := protojson.Unmarshal(entry.Value(), &resp); err != nil {
      return nil, fmt.Errorf("failed to decode KV value: %w", err)
    }
  } else {
    if err := proto.Unmarshal(entry.Value(), &resp); err != nil {
      return nil, fmt.Errorf("failed to decode KV value: %w", err)
    }
  }
  return &resp, nil
}

// Put{{.GoName}}ToKV writes a {{.Output.GoIdent.GoName}} directly to the KV Store.
// Requires the client to be created with WithNatsClientJetStream.
func (c *{{$.Service.GoName}}NatsClient) Put{{.GoName}}ToKV(ctx context.Context, key string, val *{{.Output.GoIdent.GoName}}) error {
  if c.js == nil {
    return errors.New("JetStream not configured; use WithNatsClientJetStream to enable KV writes")
  }
  var data []byte
  var err error
  if c.useJSON {
    data, err = protojson.Marshal(val)
  } else {
    data, err = proto.Marshal(val)
  }
  if err != nil {
    return fmt.Errorf("failed to encode value: %w", err)
  }
  kv, err := c.js.KeyValue(ctx, "{{$endpointOpts.KVStore.Bucket}}")
  if err != nil {
    return fmt.Errorf("failed to open KV bucket \"{{$endpointOpts.KVStore.Bucket}}\": %w", err)
  }
  if _, err := kv.Put(ctx, key, data); err != nil {
    return fmt.Errorf("KV put failed for key %q: %w", key, err)
  }
  return nil
}
{{- end}}

{{- if $endpointOpts.ObjectStore}}

// Get{{.GoName}}FromObjectStore reads a {{.GoName}} response directly from the Object Store.
// The key should match the key_template pattern used when the response was persisted.
// Requires the client to be created with WithNatsClientJetStream.
func (c *{{$.Service.GoName}}NatsClient) Get{{.GoName}}FromObjectStore(ctx context.Context, key string) (*{{.Output.GoIdent.GoName}}, error) {
  if c.js == nil {
    return nil, errors.New("JetStream not configured; use WithNatsClientJetStream to enable Object Store reads")
  }
  obj, err := c.js.ObjectStore(ctx, "{{$endpointOpts.ObjectStore.Bucket}}")
  if err != nil {
    return nil, fmt.Errorf("failed to open Object Store bucket \"{{$endpointOpts.ObjectStore.Bucket}}\": %w", err)
  }
  data, err := obj.GetBytes(ctx, key)
  if err != nil {
    return nil, fmt.Errorf("Object Store get failed for key %q: %w", key, err)
  }
  var resp {{.Output.GoIdent.GoName}}
  if c.useJSON {
    if err := protojson.Unmarshal(data, &resp); err != nil {
      return nil, fmt.Errorf("failed to decode Object Store value: %w", err)
    }
  } else {
    if err := proto.Unmarshal(data, &resp); err != nil {
      return nil, fmt.Errorf("failed to decode Object Store value: %w", err)
    }
  }
  return &resp, nil
}

// Put{{.GoName}}ToObjectStore writes a {{.Output.GoIdent.GoName}} directly to the Object Store.
// Requires the client to be created with WithNatsClientJetStream.
func (c *{{$.Service.GoName}}NatsClient) Put{{.GoName}}ToObjectStore(ctx context.Context, key string, val *{{.Output.GoIdent.GoName}}) error {
  if c.js == nil {
    return errors.New("JetStream not configured; use WithNatsClientJetStream to enable Object Store writes")
  }
  var data []byte
  var err error
  if c.useJSON {
    data, err = protojson.Marshal(val)
  } else {
    data, err = proto.Marshal(val)
  }
  if err != nil {
    return fmt.Errorf("failed to encode value: %w", err)
  }
  obj, err := c.js.ObjectStore(ctx, "{{$endpointOpts.ObjectStore.Bucket}}")
  if err != nil {
    return fmt.Errorf("failed to open Object Store bucket \"{{$endpointOpts.ObjectStore.Bucket}}\": %w", err)
  }
  if _, err := obj.PutBytes(ctx, key, data); err != nil {
    return fmt.Errorf("Object Store put failed for key %q: %w", key, err)
  }
  return nil
}
{{- end}}

{{- end}}{{/* end IsUnary */}}

{{- if IsServerStreaming .}}
{{- if not (IsClientStreaming .)}}
// {{$.Service.GoName}}_{{.GoName}}_ClientStream is the client-side stream receiver for {{.GoName}}.
type {{$.Service.GoName}}_{{.GoName}}_ClientStream struct {
  receiver *ClientStreamReceiver
  useJSON  bool
}

// Recv blocks until the next response message arrives from the server.
// Returns an error containing "EOF" when the stream is complete.
func (s *{{$.Service.GoName}}_{{.GoName}}_ClientStream) Recv(ctx context.Context) (*{{.Output.GoIdent.GoName}}, error) {
  msg, err := s.receiver.Recv(ctx)
  if err != nil {
    return nil, err
  }
  var resp {{.Output.GoIdent.GoName}}
  if s.useJSON {
    if err := protojson.Unmarshal(msg.Data, &resp); err != nil {
      return nil, fmt.Errorf("failed to decode stream message: %w", err)
    }
  } else {
    if err := proto.Unmarshal(msg.Data, &resp); err != nil {
      return nil, fmt.Errorf("failed to decode stream message: %w", err)
    }
  }
  return &resp, nil
}

// Close unsubscribes from the stream.
func (s *{{$.Service.GoName}}_{{.GoName}}_ClientStream) Close() error {
  return s.receiver.Close()
}

// {{.GoName}} initiates a server-streaming RPC call.
// Returns a stream that yields responses from the server.
func (c *{{$.Service.GoName}}NatsClient) {{.GoName}}(ctx context.Context, req *{{.Input.GoIdent.GoName}}) (*{{$.Service.GoName}}_{{.GoName}}_ClientStream, error) {
  subject := c.subjectPrefix + ".{{ToSnakeCase .GoName}}"

  var data []byte
  var err error
  if c.useJSON {
    data, err = protojson.Marshal(req)
  } else {
    data, err = proto.Marshal(req)
  }
  if err != nil {
    return nil, fmt.Errorf("failed to marshal request: %w", err)
  }

  // Create inbox for receiving streamed responses
  inbox := nats.NewInbox()
  receiver, err := newClientStreamReceiver(c.nc, inbox, false)
  if err != nil {
    return nil, fmt.Errorf("failed to setup stream: %w", err)
  }

  // Send request with our inbox as Reply-To header
  msg := &nats.Msg{
    Subject: subject,
    Data:    data,
    Header:  nats.Header{},
  }
  msg.Header.Set("Reply-To", inbox)

  // Add outgoing headers from context
  if headers := OutgoingHeaders(ctx); headers != nil {
    for k, v := range headers {
      for _, val := range v {
        msg.Header.Add(k, val)
      }
    }
  }

  if err := c.nc.PublishMsg(msg); err != nil {
    receiver.Close()
    return nil, fmt.Errorf("failed to send streaming request: %w", err)
  }

  return &{{$.Service.GoName}}_{{.GoName}}_ClientStream{
    receiver: receiver,
    useJSON:  c.useJSON,
  }, nil
}
{{- end}}
{{- end}}

{{- if IsBidiStreaming .}}
// {{$.Service.GoName}}_{{.GoName}}_ClientStream is the client-side bidi stream for {{.GoName}}.
type {{$.Service.GoName}}_{{.GoName}}_ClientStream struct {
  nc       *nats.Conn
  sendTo   string              // Server's inbox for sending messages
  receiver *ClientStreamReceiver  // For receiving server messages
  useJSON  bool
  seq      int
  mu       sync.Mutex
}

// Send sends a message to the server.
func (s *{{$.Service.GoName}}_{{.GoName}}_ClientStream) Send(msg *{{.Input.GoIdent.GoName}}) error {
  var data []byte
  var err error
  if s.useJSON {
    data, err = protojson.Marshal(msg)
  } else {
    data, err = proto.Marshal(msg)
  }
  if err != nil {
    return fmt.Errorf("failed to marshal stream message: %w", err)
  }
  s.mu.Lock()
  s.seq++
  seq := s.seq
  s.mu.Unlock()
  m := &nats.Msg{
    Subject: s.sendTo,
    Data:    data,
    Header:  nats.Header{},
  }
  m.Header.Set(natsStreamSeqHeader, strconv.Itoa(seq))
  return s.nc.PublishMsg(m)
}

// Recv blocks until the next response arrives from the server.
func (s *{{$.Service.GoName}}_{{.GoName}}_ClientStream) Recv(ctx context.Context) (*{{.Output.GoIdent.GoName}}, error) {
  natsMsg, err := s.receiver.Recv(ctx)
  if err != nil {
    return nil, err
  }
  var resp {{.Output.GoIdent.GoName}}
  if s.useJSON {
    if err := protojson.Unmarshal(natsMsg.Data, &resp); err != nil {
      return nil, fmt.Errorf("failed to decode stream message: %w", err)
    }
  } else {
    if err := proto.Unmarshal(natsMsg.Data, &resp); err != nil {
      return nil, fmt.Errorf("failed to decode stream message: %w", err)
    }
  }
  return &resp, nil
}

// CloseSend signals end of client messages.
func (s *{{$.Service.GoName}}_{{.GoName}}_ClientStream) CloseSend() error {
  m := &nats.Msg{
    Subject: s.sendTo,
    Header:  nats.Header{},
  }
  m.Header.Set(natsStreamEndHeader, "true")
  return s.nc.PublishMsg(m)
}

// Close unsubscribes from server messages.
func (s *{{$.Service.GoName}}_{{.GoName}}_ClientStream) Close() error {
  return s.receiver.Close()
}

// {{.GoName}} initiates a bidirectional streaming RPC call.
func (c *{{$.Service.GoName}}NatsClient) {{.GoName}}(ctx context.Context) (*{{$.Service.GoName}}_{{.GoName}}_ClientStream, error) {
  subject := c.subjectPrefix + ".{{ToSnakeCase .GoName}}"

  // Create inbox for receiving server responses
  clientInbox := nats.NewInbox()
  receiver, err := newClientStreamReceiver(c.nc, clientInbox, false)
  if err != nil {
    return nil, fmt.Errorf("failed to setup stream: %w", err)
  }

  // Send initial handshake to get server's inbox
  msg := &nats.Msg{
    Subject: subject,
    Header:  nats.Header{},
  }
  msg.Header.Set("Reply-To", clientInbox)

  ackMsg, err := c.nc.RequestMsgWithContext(ctx, msg)
  if err != nil {
    receiver.Close()
    return nil, fmt.Errorf("failed to initiate bidi stream: %w", err)
  }

  serverInbox := ackMsg.Header.Get(natsStreamInboxHeader)
  if serverInbox == "" {
    receiver.Close()
    return nil, fmt.Errorf("server did not provide stream inbox")
  }

  return &{{$.Service.GoName}}_{{.GoName}}_ClientStream{
    nc:       c.nc,
    sendTo:   serverInbox,
    receiver: receiver,
    useJSON:  c.useJSON,
  }, nil
}
{{- end}}

{{- if IsClientStreaming .}}
{{- if not (IsServerStreaming .)}}
// {{$.Service.GoName}}_{{.GoName}}_ClientStream is the client-side sender stream for {{.GoName}}.
type {{$.Service.GoName}}_{{.GoName}}_ClientStream struct {
  nc       *nats.Conn
  sendTo   string              // Server's inbox
  replyTo  string              // Our inbox for final response
  useJSON  bool
  seq      int
  mu       sync.Mutex
}

// Send sends a message to the server.
func (s *{{$.Service.GoName}}_{{.GoName}}_ClientStream) Send(msg *{{.Input.GoIdent.GoName}}) error {
  var data []byte
  var err error
  if s.useJSON {
    data, err = protojson.Marshal(msg)
  } else {
    data, err = proto.Marshal(msg)
  }
  if err != nil {
    return fmt.Errorf("failed to marshal stream message: %w", err)
  }
  s.mu.Lock()
  s.seq++
  seq := s.seq
  s.mu.Unlock()
  m := &nats.Msg{
    Subject: s.sendTo,
    Data:    data,
    Header:  nats.Header{},
  }
  m.Header.Set(natsStreamSeqHeader, strconv.Itoa(seq))
  return s.nc.PublishMsg(m)
}

// CloseAndRecv signals end of client messages and waits for the server's response.
func (s *{{$.Service.GoName}}_{{.GoName}}_ClientStream) CloseAndRecv(ctx context.Context) (*{{.Output.GoIdent.GoName}}, error) {
  // Send end-of-stream marker
  m := &nats.Msg{
    Subject: s.sendTo,
    Header:  nats.Header{},
  }
  m.Header.Set(natsStreamEndHeader, "true")
  if err := s.nc.PublishMsg(m); err != nil {
    return nil, fmt.Errorf("failed to close send: %w", err)
  }

  // Wait for final response on our reply inbox
  sub, err := s.nc.SubscribeSync(s.replyTo)
  if err != nil {
    return nil, fmt.Errorf("failed to subscribe for response: %w", err)
  }
  defer sub.Unsubscribe()

  natsMsg, err := sub.NextMsgWithContext(ctx)
  if err != nil {
    return nil, fmt.Errorf("failed to receive response: %w", err)
  }

  var resp {{.Output.GoIdent.GoName}}
  if s.useJSON {
    if err := protojson.Unmarshal(natsMsg.Data, &resp); err != nil {
      return nil, fmt.Errorf("failed to decode response: %w", err)
    }
  } else {
    if err := proto.Unmarshal(natsMsg.Data, &resp); err != nil {
      return nil, fmt.Errorf("failed to decode response: %w", err)
    }
  }
  return &resp, nil
}

// {{.GoName}} initiates a client-streaming RPC call.
func (c *{{$.Service.GoName}}NatsClient) {{.GoName}}(ctx context.Context) (*{{$.Service.GoName}}_{{.GoName}}_ClientStream, error) {
  subject := c.subjectPrefix + ".{{ToSnakeCase .GoName}}"

  // Create inbox for receiving the final response
  replyInbox := nats.NewInbox()

  // Send initial handshake to get server's inbox
  msg := &nats.Msg{
    Subject: subject,
    Header:  nats.Header{},
  }
  msg.Header.Set("Reply-To", replyInbox)

  ackMsg, err := c.nc.RequestMsgWithContext(ctx, msg)
  if err != nil {
    return nil, fmt.Errorf("failed to initiate client stream: %w", err)
  }

  serverInbox := ackMsg.Header.Get(natsStreamInboxHeader)
  if serverInbox == "" {
    return nil, fmt.Errorf("server did not provide stream inbox")
  }

  return &{{$.Service.GoName}}_{{.GoName}}_ClientStream{
    nc:      c.nc,
    sendTo:  serverInbox,
    replyTo: replyInbox,
    useJSON: c.useJSON,
  }, nil
}
{{- end}}
{{- end}}

{{end -}}
{{end -}}
// Endpoints returns information about all service endpoints this client can call.
// This is useful for debugging, monitoring, and introspection.
func (c *{{.Service.GoName}}NatsClient) Endpoints() []{{.Service.GoName}}EndpointInfo {
  return []{{.Service.GoName}}EndpointInfo{
{{- range .Service.Methods}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
    {Name: "{{.GoName}}", Subject: c.subjectPrefix + ".{{ToSnakeCase .GoName}}"},
{{- end}}
{{- end}}
  }
}
