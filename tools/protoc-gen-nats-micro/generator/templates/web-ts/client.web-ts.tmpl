{{- /* Client implementation for web-ts (protoc-gen-es v2) */ -}}
/**
 * Endpoint information for {{.Service.GoName}}
 */
export interface {{.Service.GoName}}EndpointInfo {
  name: string;
  subject: string;
}

/**
 * {{.Service.GoName}}NatsClient is the interface for the NATS client
 * This interface allows for easier dependency injection and testing
 */
export interface I{{.Service.GoName}}NatsClient {
{{- range .Service.Methods}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
{{- if IsUnary .}}
  {{ToLowerFirst .GoName}}(request: pb.{{.Input.GoIdent.GoName}}, opts?: RequestOptions): Promise<pb.{{.Output.GoIdent.GoName}}>;
{{- if $endpointOpts.KVStore}}
  get{{.GoName}}FromKV(key: string): Promise<pb.{{.Output.GoIdent.GoName}}>;
  put{{.GoName}}ToKV(key: string, val: pb.{{.Output.GoIdent.GoName}}): Promise<void>;
{{- end}}
{{- if $endpointOpts.ObjectStore}}
  get{{.GoName}}FromObjectStore(key: string): Promise<pb.{{.Output.GoIdent.GoName}}>;
  put{{.GoName}}ToObjectStore(key: string, val: pb.{{.Output.GoIdent.GoName}}): Promise<void>;
{{- end}}
{{- else if IsServerStreaming .}}
{{- if not (IsClientStreaming .)}}
  {{ToLowerFirst .GoName}}(request: pb.{{.Input.GoIdent.GoName}}): Promise<ClientStreamReceiver<pb.{{.Output.GoIdent.GoName}}>>;
{{- end}}
{{- end}}
{{- end}}
{{- end}}
  endpoints(): {{.Service.GoName}}EndpointInfo[];
}

/**
 * Configuration options for {{.Service.GoName}}NatsClient
 */
export interface {{.Service.GoName}}ClientOptions {
  subjectPrefix?: string;
  timeout?: number; // milliseconds
  clientInterceptors?: UnaryClientInterceptor[]; // Client-side interceptors
  jetstream?: any; // Optional JetStream client for KV/ObjectStore reads
}

/**
 * {{.Service.GoName}}NatsClient is the concrete implementation
 * The client sends requests over NATS using protobuf serialization (protoc-gen-es v2).
 */
export class {{.Service.GoName}}NatsClient implements I{{.Service.GoName}}NatsClient {
  private readonly nc: NatsConnection;
  private readonly subjectPrefix: string;
  private readonly timeout?: number;
  private readonly interceptor?: UnaryClientInterceptor;
  private readonly js?: any; // Optional JetStream client

  /**
   * Create a new NATS client for {{.Service.GoName}}
   * @param nc - NATS connection (from 'nats' or 'nats.ws')
   * @param options - Client configuration options
   */
  constructor(nc: NatsConnection, options?: {{.Service.GoName}}ClientOptions) {
    this.nc = nc;
    this.subjectPrefix = options?.subjectPrefix || '{{.Options.SubjectPrefix}}';
    this.timeout = options?.timeout;
    this.js = options?.jetstream;
    
    // Chain client interceptors
    this.interceptor = options?.clientInterceptors
      ? chainUnaryClientInterceptors(options.clientInterceptors)
      : undefined;
  }

{{range .Service.Methods -}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
{{- if IsUnary .}}
  /**
   * {{.GoName}} sends a {{.GoName}} request to the service via NATS.
   * @param request - The request message
   * @param opts - Optional request options
   * @returns Promise resolving to the response message
   * @throws {{$.Service.GoName}}Error if the request fails or the service returns an error
   */
  async {{ToLowerFirst .GoName}}(
    request: pb.{{.Input.GoIdent.GoName}},
    opts?: RequestOptions & { headers?: MsgHdrs }
  ): Promise<pb.{{.Output.GoIdent.GoName}}> {
    const method = '{{.GoName}}';
    
    // Define the invoker function that performs the actual NATS call
    const invoker: UnaryInvoker = async (m: string, req: any, reply: any, hdrs?: MsgHdrs, responseHeaders?: { value?: MsgHdrs }) => {
      const subject = `${this.subjectPrefix}.{{ToSnakeCase .GoName}}`;
      
      // Serialize request using protoc-gen-es v2 functional API
      const data = toBinary(pb.{{.Input.GoIdent.GoName}}Schema, req);
      
      // Send request with optional headers
      const requestOpts: RequestOptions = {
        ...opts,
        timeout: opts?.timeout || this.timeout,
        headers: hdrs || opts?.headers,
      };
      
      const msg = await this.nc.request(subject, data, requestOpts);
      
      // Store response headers for interceptor access
      if (responseHeaders && msg.headers) {
        responseHeaders.value = msg.headers;
      }
      
      // Check for error response (NATS micro sets these headers via Request.Error())
      const errorCode = msg.headers?.get('Nats-Service-Error-Code');
      if (errorCode) {
        const errorMessage = msg.headers?.get('Nats-Service-Error') || 'Unknown error';
        throw new {{$.Service.GoName}}Error(errorCode, method, errorMessage, msg.data);
      }
      
      // Deserialize response using protoc-gen-es v2 functional API
      const decoded = fromBinary(pb.{{.Output.GoIdent.GoName}}Schema, msg.data);
      Object.assign(reply, decoded);
    };

    const response = create(pb.{{.Output.GoIdent.GoName}}Schema) as pb.{{.Output.GoIdent.GoName}};
    const responseHeaders = { value: undefined as MsgHdrs | undefined };
    
    // Execute through interceptor chain if configured
    if (this.interceptor) {
      await this.interceptor(method, request, response, invoker, opts?.headers, responseHeaders);
    } else {
      await invoker(method, request, response, opts?.headers, responseHeaders);
    }
    
    return response;
  }

{{- if $endpointOpts.KVStore}}

  /**
   * Read a cached {{.GoName}} response directly from the KV Store.
   * @param key - The KV key matching the key_template pattern
   * @throws Error if JetStream is not configured or the key is not found
   */
  async get{{.GoName}}FromKV(key: string): Promise<pb.{{.Output.GoIdent.GoName}}> {
    if (!this.js) {
      throw new Error('JetStream not configured; pass jetstream option to enable KV reads');
    }
    const kv = await this.js.views.kv('{{$endpointOpts.KVStore.Bucket}}');
    const entry = await kv.get(key);
    if (!entry || !entry.value) {
      throw new Error(`KV key "${key}" not found in bucket "{{$endpointOpts.KVStore.Bucket}}"`);
    }
    return fromBinary(pb.{{.Output.GoIdent.GoName}}Schema, entry.value);
  }

  /**
   * Write a {{.Output.GoIdent.GoName}} directly to the KV Store.
   * @param key - The KV key
   * @param val - The value to store
   * @throws Error if JetStream is not configured
   */
  async put{{.GoName}}ToKV(key: string, val: pb.{{.Output.GoIdent.GoName}}): Promise<void> {
    if (!this.js) {
      throw new Error('JetStream not configured; pass jetstream option to enable KV writes');
    }
    const kv = await this.js.views.kv('{{$endpointOpts.KVStore.Bucket}}');
    const data = toBinary(pb.{{.Output.GoIdent.GoName}}Schema, val);
    await kv.put(key, data);
  }
{{- end}}

{{- if $endpointOpts.ObjectStore}}

  /**
   * Read a cached {{.GoName}} response directly from the Object Store.
   * @param key - The object key matching the key_template pattern
   * @throws Error if JetStream is not configured or the key is not found
   */
  async get{{.GoName}}FromObjectStore(key: string): Promise<pb.{{.Output.GoIdent.GoName}}> {
    if (!this.js) {
      throw new Error('JetStream not configured; pass jetstream option to enable Object Store reads');
    }
    const obj = await this.js.views.os('{{$endpointOpts.ObjectStore.Bucket}}');
    const data = await obj.getBlob(key);
    if (!data) {
      throw new Error(`Object "${key}" not found in bucket "{{$endpointOpts.ObjectStore.Bucket}}"`);
    }
    return fromBinary(pb.{{.Output.GoIdent.GoName}}Schema, data);
  }

  /**
   * Write a {{.Output.GoIdent.GoName}} directly to the Object Store.
   * @param key - The object key
   * @param val - The value to store
   * @throws Error if JetStream is not configured
   */
  async put{{.GoName}}ToObjectStore(key: string, val: pb.{{.Output.GoIdent.GoName}}): Promise<void> {
    if (!this.js) {
      throw new Error('JetStream not configured; pass jetstream option to enable Object Store writes');
    }
    const obj = await this.js.views.os('{{$endpointOpts.ObjectStore.Bucket}}');
    const data = toBinary(pb.{{.Output.GoIdent.GoName}}Schema, val);
    await obj.putBlob({ name: key }, data);
  }
{{- end}}

{{- end}}{{/* end IsUnary */}}

{{- if IsServerStreaming .}}
{{- if not (IsClientStreaming .)}}
  /**
   * {{.GoName}} initiates a server-streaming RPC call.
   * Returns a receiver that yields response messages from the server.
   */
  async {{ToLowerFirst .GoName}}(request: pb.{{.Input.GoIdent.GoName}}): Promise<ClientStreamReceiver<pb.{{.Output.GoIdent.GoName}}>> {
    const subject = `${this.subjectPrefix}.{{ToSnakeCase .GoName}}`;
    const data = toBinary(pb.{{.Input.GoIdent.GoName}}Schema, request);
    
    // Create inbox for receiving streamed responses
    const inbox = this.nc.options.inboxPrefix 
      ? `${this.nc.options.inboxPrefix}.${Date.now()}.${Math.random().toString(36).slice(2)}`
      : `_INBOX.${Date.now()}.${Math.random().toString(36).slice(2)}`;
    
    const sub = this.nc.subscribe(inbox);
    
    // Send request with inbox as Reply-To
    const h = headers();
    h.set('Reply-To', inbox);
    this.nc.publish(subject, data, { headers: h });
    
    return new ClientStreamReceiver<pb.{{.Output.GoIdent.GoName}}>(sub, (msgData: Uint8Array) => {
      return fromBinary(pb.{{.Output.GoIdent.GoName}}Schema, msgData);
    });
  }
{{- end}}
{{- end}}

{{end -}}
{{end -}}
  /**
   * Returns information about all service endpoints this client can call.
   * This is useful for debugging, monitoring, and introspection.
   */
  endpoints(): {{.Service.GoName}}EndpointInfo[] {
    return [
{{- range .Service.Methods}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
      { name: '{{.GoName}}', subject: `${this.subjectPrefix}.{{ToSnakeCase .GoName}}` },
{{- end}}
{{- end}}
    ];
  }
}

/**
 * ClientStreamReceiver receives streamed messages from the server
 */
export class ClientStreamReceiver<T> {
  private done = false;

  constructor(
    private readonly sub: any,
    private readonly decoder: (data: Uint8Array) => T
  ) {}

  /**
   * Async iterator for receiving streamed messages
   */
  async *[Symbol.asyncIterator](): AsyncIterableIterator<T> {
    for await (const msg of this.sub) {
      if (msg.headers?.get('Nats-Stream-End') === 'true') {
        // Check for error
        const errorCode = msg.headers?.get('Nats-Service-Error-Code') || msg.headers?.get('Status');
        if (errorCode) {
          const desc = msg.headers?.get('Nats-Service-Error') || msg.headers?.get('Description') || 'Stream error';
          throw new Error(`Stream error [${errorCode}]: ${desc}`);
        }
        this.done = true;
        break;
      }
      yield this.decoder(msg.data);
    }
  }

  /**
   * Close the stream subscription
   */
  close(): void {
    this.sub.unsubscribe();
  }
}
