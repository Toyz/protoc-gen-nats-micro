{{- /* Service interface and registration function */ -}}
{{- if not .Options.SubjectPrefix }}
// WARNING: Service {{.Service.GoName}} is missing required option (nats.micro.service).subject_prefix
// The service will not function correctly without a subject prefix.

{{end -}}
/**
 * {{.Service.GoName}}Nats is the NATS service interface for {{.Service.GoName}}
 */
export interface I{{.Service.GoName}}Nats {
{{- range .Service.Methods}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
  {{ToLowerFirst .GoName}}(request: pb.{{.Input.GoIdent.GoName}}): Promise<pb.{{.Output.GoIdent.GoName}}>;
{{- end}}
{{- end}}
}

/**
 * Configuration options for service registration
 */
export interface {{.Service.GoName}}RegisterOptions {
  name?: string;
  version?: string;
  description?: string;
  subjectPrefix?: string;
  timeout?: number; // milliseconds (0 = no timeout)
  metadata?: Record<string, string>;
  serverInterceptors?: UnaryServerInterceptor[]; // Server-side interceptors
  jetstream?: any; // Optional JetStream client for KV/ObjectStore operations
}

/**
 * {{.Service.GoName}}Service wraps the registered NATS micro service
 */
export class {{.Service.GoName}}Service {
  constructor(
    private readonly service: Service,
    private readonly subjectPrefix: string
  ) {}

  /**
   * Returns information about all service endpoints
   * This is useful for debugging, monitoring, and service discovery
   */
  endpoints(): {{.Service.GoName}}EndpointInfo[] {
    return [
{{- range .Service.Methods}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
      { name: '{{.GoName}}', subject: `${this.subjectPrefix}.{{ToSnakeCase .GoName}}` },
{{- end}}
{{- end}}
    ];
  }

  /**
   * Stop the service
   */
  async stop(): Promise<void> {
    return this.service.stop();
  }

  /**
   * Check if the service is stopped
   */
  isStopped(): boolean {
    return this.service.stopped;
  }

  /**
   * Get service info
   */
  info(): any {
    return this.service.info();
  }

  /**
   * Get service stats
   */
  stats(): any {
    return this.service.stats();
  }
}

/**
 * Register{{.Service.GoName}}Handlers registers the service with NATS micro handlers
 * 
 * Service: {{.Options.Name}} v{{.Options.Version}}
{{- if .Options.Description}}
 * Description: {{.Options.Description}}
{{- end}}
 * Subject prefix: {{.Options.SubjectPrefix}}
{{- if .Options.Metadata}}
 * Metadata: {{range $key, $value := .Options.Metadata}}{{$key}}={{$value}} {{end}}
{{- end}}
 * 
 * @param nc - NATS connection
 * @param impl - Service implementation
 * @param options - Registration options
 * @returns Promise resolving to the registered service
 */
export async function register{{.Service.GoName}}Handlers(
  nc: NatsConnection,
  impl: I{{.Service.GoName}}Nats,
  options?: {{.Service.GoName}}RegisterOptions
): Promise<{{.Service.GoName}}Service> {
  const config: ServiceConfig = {
    name: options?.name || '{{.Options.Name}}',
    version: options?.version || '{{.Options.Version}}',
    description: options?.description || '{{.Options.Description}}',
    metadata: {
{{- range $key, $value := .Options.Metadata}}
      '{{$key}}': '{{$value}}',
{{- end}}
      ...options?.metadata,
    },
  };

  const subjectPrefix = options?.subjectPrefix || '{{.Options.SubjectPrefix}}';
  const timeout = options?.timeout || {{.Options.Timeout.Seconds}}000; // Convert seconds to milliseconds

  // Create service
  const service = await nc.services.add(config);

  // Chain server interceptors
  const chainedInterceptor = options?.serverInterceptors 
    ? chainUnaryServerInterceptors(options.serverInterceptors)
    : undefined;

  // Create handlers
  const handlers = new {{.Service.GoName}}Handlers(impl, timeout, chainedInterceptor, options?.jetstream);

  // Auto-create KV and Object Store buckets if JetStream is available
  if (options?.jetstream) {
    const js = options.jetstream;
    {{- range .Service.Methods}}
    {{- $eopts := GetEndpointOptions .}}
    {{- if $eopts.KVStore}}
    // Auto-create KV bucket "{{$eopts.KVStore.Bucket}}" for {{.GoName}}
    try {
      await js.views.kv('{{$eopts.KVStore.Bucket}}', {
        {{- if $eopts.KVStore.Description}}
        description: '{{$eopts.KVStore.Description}}',
        {{- end}}
        {{- if $eopts.KVStore.MaxHistory}}
        history: {{$eopts.KVStore.MaxHistory}},
        {{- end}}
        {{- if $eopts.KVStore.TTL.Nanoseconds}}
        ttl: {{$eopts.KVStore.TTL.Milliseconds}},
        {{- end}}
      });
    } catch (e) {
      console.warn(`[nats-micro] WARN: failed to create KV bucket "{{$eopts.KVStore.Bucket}}": ${e}`);
    }
    {{- end}}
    {{- if $eopts.ObjectStore}}
    // Auto-create Object Store bucket "{{$eopts.ObjectStore.Bucket}}" for {{.GoName}}
    try {
      await js.views.os('{{$eopts.ObjectStore.Bucket}}', {
        {{- if $eopts.ObjectStore.Description}}
        description: '{{$eopts.ObjectStore.Description}}',
        {{- end}}
        {{- if $eopts.ObjectStore.TTL.Nanoseconds}}
        ttl: {{$eopts.ObjectStore.TTL.Milliseconds}},
        {{- end}}
      });
    } catch (e) {
      console.warn(`[nats-micro] WARN: failed to create Object Store bucket "{{$eopts.ObjectStore.Bucket}}": ${e}`);
    }
    {{- end}}
    {{- end}}
  }

  // Add endpoints
  const group = subjectPrefix ? service.addGroup(subjectPrefix) : service;
  
{{range .Service.Methods -}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
  await group.addEndpoint('{{ToSnakeCase .GoName}}', {
    handler: handlers.{{ToLowerFirst .GoName}}.bind(handlers),
{{- if $endpointOpts.Metadata}}
    metadata: {
{{- range $key, $value := $endpointOpts.Metadata}}
      '{{$key}}': '{{$value}}',
{{- end}}
    },
{{- end}}
  });
{{end -}}
{{end}}

  return new {{.Service.GoName}}Service(service, subjectPrefix);
}

/**
 * Internal handlers class that wraps the service implementation
 */
class {{.Service.GoName}}Handlers {
  constructor(
    private readonly impl: I{{.Service.GoName}}Nats,
    private readonly serviceTimeout: number, // Default timeout for all endpoints (milliseconds)
    private readonly interceptor?: UnaryServerInterceptor, // Chained interceptors
    private readonly js?: any // Optional JetStream client
  ) {}

{{range .Service.Methods -}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
  async {{ToLowerFirst .GoName}}(err: ServiceError | null, msg: any): Promise<void> {
    if (err) {
      throw err;
    }

    try {
      // Decode request
      const request = pb.{{.Input.GoIdent.GoName}}.fromBinary(msg.data);

      // Determine effective timeout: endpoint-specific timeout overrides service timeout
      const timeout = {{if gt $endpointOpts.Timeout.Nanoseconds 0}}{{$endpointOpts.Timeout.Milliseconds}}{{else}}this.serviceTimeout{{end}};

      // Extract incoming headers from NATS message for use in interceptors/service
      const headers = msg.headers;

      // Define the handler function
      const handler = async (req: any): Promise<any> => {
        if (timeout > 0) {
          return Promise.race([
            this.impl.{{ToLowerFirst .GoName}}(req),
            new Promise<never>((_, reject) =>
              setTimeout(() => reject(new Error('Request timeout')), timeout)
            ),
          ]);
        } else {
          return this.impl.{{ToLowerFirst .GoName}}(req);
        }
      };

      // Execute through interceptor chain if configured
      let response: pb.{{.Output.GoIdent.GoName}};
      if (this.interceptor) {
        const info: UnaryServerInfo = {
          service: '{{$.Service.GoName}}',
          method: '{{.GoName}}',
          subject: '{{$.Options.SubjectPrefix}}.{{ToSnakeCase .GoName}}',
          headers: headers, // Pass headers to interceptor
        };
        response = await this.interceptor(request, info, handler);
      } else {
        response = await handler(request);
      }

      // Encode and send response
      const data = pb.{{.Output.GoIdent.GoName}}.toBinary(response);

      {{- /* KV Store persistence */}}
      {{- if $endpointOpts.KVStore}}
      {{- if not $endpointOpts.KVStore.ClientOnly}}
      // Auto-persist response to KV Store (bucket: "{{$endpointOpts.KVStore.Bucket}}")
      if (this.js) {
        try {
          const kvKey = {{ResolveKeyTemplateTS $endpointOpts.KVStore.KeyTemplate .}};
          const kv = await this.js.views.kv('{{$endpointOpts.KVStore.Bucket}}');
          await kv.put(kvKey, data);
        } catch (kvErr) {
          console.warn(`[nats-micro] WARN: failed to persist {{.GoName}} to KV: ${kvErr}`);
        }
      }
      {{- end}}
      {{- end}}

      {{- /* Object Store persistence */}}
      {{- if $endpointOpts.ObjectStore}}
      {{- if not $endpointOpts.ObjectStore.ClientOnly}}
      // Auto-persist response to Object Store (bucket: "{{$endpointOpts.ObjectStore.Bucket}}")
      if (this.js) {
        try {
          const objKey = {{ResolveKeyTemplateTS $endpointOpts.ObjectStore.KeyTemplate .}};
          const obj = await this.js.views.os('{{$endpointOpts.ObjectStore.Bucket}}');
          await obj.putBlob({ name: objKey }, data);
        } catch (objErr) {
          console.warn(`[nats-micro] WARN: failed to persist {{.GoName}} to Object Store: ${objErr}`);
        }
      }
      {{- end}}
      {{- end}}

      msg.respond(data);
    } catch (error) {
      // Handle errors
      let code = {{$.Service.GoName}}ErrorCode.INTERNAL;
      let message = error instanceof Error ? error.message : 'Unknown error';
      let data: Uint8Array | undefined;

      // Check if error is a {{$.Service.GoName}}Error
      if (is{{$.Service.GoName}}Error(error)) {
        code = error.code as any;
        message = error.message;
        data = error.data;
      }

      // Send error response
      const h = headers();
      h.set('Status', code);
      h.set('Description', message);
      msg.respond(data || new Uint8Array(0), { headers: h });
    }
  }
{{- end}}
{{- end}}
}
