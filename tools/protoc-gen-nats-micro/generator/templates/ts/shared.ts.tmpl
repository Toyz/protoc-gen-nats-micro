{{- /* Shared types for all services in a proto file */ -}}
// This file contains shared types used by all NATS microservices in this proto file
// It is generated once per proto file to avoid duplication when multiple services exist

import type { MsgHdrs } from 'nats';

/**
 * UnaryServerInfo contains information about a unary RPC
 */
export interface UnaryServerInfo {
  service: string;  // Service name
  method: string;   // Method name
  subject: string;  // NATS subject
  headers?: MsgHdrs; // Incoming NATS headers
}

/**
 * UnaryHandler is the actual handler function to be called
 */
export type UnaryHandler = (request: any) => Promise<any>;

/**
 * UnaryServerInterceptor is middleware that can intercept unary RPC calls on the server
 * It receives the request, RPC info, and the handler to call.
 * The interceptor can inspect/modify the request, handle auth, logging, etc.
 * It must call handler(req) to continue the chain or return early.
 */
export type UnaryServerInterceptor = (
  request: any,
  info: UnaryServerInfo,
  handler: UnaryHandler
) => Promise<any>;

/**
 * UnaryInvoker is called by a UnaryClientInterceptor to complete the RPC
 * Returns response headers via the responseHeaders parameter
 */
export type UnaryInvoker = (
  method: string,
  request: any,
  reply: any,
  headers?: MsgHdrs,
  responseHeaders?: { value?: MsgHdrs }
) => Promise<void>;

/**
 * UnaryClientInterceptor is middleware that can intercept unary RPC calls on the client
 * It receives the method name, request, reply, optional headers, invoker, and a container for response headers.
 * The interceptor can inspect/modify requests, handle retries, logging, etc.
 * It must call invoker(method, req, reply, headers, responseHeaders) to continue the chain.
 * After invoker completes, responseHeaders.value will contain the server's response headers.
 */
export type UnaryClientInterceptor = (
  method: string,
  request: any,
  reply: any,
  invoker: UnaryInvoker,
  headers?: MsgHdrs,
  responseHeaders?: { value?: MsgHdrs }
) => Promise<void>;

/**
 * Chain multiple server interceptors into a single interceptor
 * Interceptors are executed in the order they are provided
 */
export function chainUnaryServerInterceptors(
  interceptors: UnaryServerInterceptor[]
): UnaryServerInterceptor | undefined {
  const n = interceptors.length;
  
  if (n === 0) {
    return undefined;
  }
  
  if (n === 1) {
    return interceptors[0];
  }
  
  return async (request: any, info: UnaryServerInfo, handler: UnaryHandler): Promise<any> => {
    // Build chain from last to first
    let chainedHandler = handler;
    for (let i = n - 1; i >= 0; i--) {
      const interceptor = interceptors[i];
      const nextHandler = chainedHandler;
      chainedHandler = async (currentReq: any) => {
        return interceptor(currentReq, info, nextHandler);
      };
    }
    return chainedHandler(request);
  };
}

/**
 * Chain multiple client interceptors into a single interceptor
 * Interceptors are executed in the order they are provided
 */
export function chainUnaryClientInterceptors(
  interceptors: UnaryClientInterceptor[]
): UnaryClientInterceptor | undefined {
  const n = interceptors.length;
  
  if (n === 0) {
    return undefined;
  }
  
  if (n === 1) {
    return interceptors[0];
  }
  
  return async (method: string, request: any, reply: any, invoker: UnaryInvoker, headers?: MsgHdrs, responseHeaders?: { value?: MsgHdrs }): Promise<void> => {
    // Build chain from last to first
    let chainedInvoker = invoker;
    for (let i = n - 1; i >= 0; i--) {
      const interceptor = interceptors[i];
      const nextInvoker = chainedInvoker;
      chainedInvoker = async (currentMethod: string, currentReq: any, currentReply: any, currentHeaders?: MsgHdrs, currentResponseHeaders?: { value?: MsgHdrs }) => {
        return interceptor(currentMethod, currentReq, currentReply, nextInvoker, currentHeaders, currentResponseHeaders);
      };
    }
    return chainedInvoker(method, request, reply, headers, responseHeaders);
  };
}
