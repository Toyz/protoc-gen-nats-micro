{{- /* Client implementation */ -}}
/**
 * Endpoint information for {{.Service.GoName}}
 */
export interface {{.Service.GoName}}EndpointInfo {
  name: string;
  subject: string;
}

/**
 * {{.Service.GoName}}NatsClient is the interface for the NATS client
 * This interface allows for easier dependency injection and testing
 */
export interface I{{.Service.GoName}}NatsClient {
{{- range .Service.Methods}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
  {{ToLowerFirst .GoName}}(request: pb.{{.Input.GoIdent.GoName}}, opts?: RequestOptions): Promise<pb.{{.Output.GoIdent.GoName}}>;
{{- if $endpointOpts.KVStore}}
  get{{.GoName}}FromKV(key: string): Promise<pb.{{.Output.GoIdent.GoName}}>;
  put{{.GoName}}ToKV(key: string, val: pb.{{.Output.GoIdent.GoName}}): Promise<void>;
{{- end}}
{{- if $endpointOpts.ObjectStore}}
  get{{.GoName}}FromObjectStore(key: string): Promise<pb.{{.Output.GoIdent.GoName}}>;
  put{{.GoName}}ToObjectStore(key: string, val: pb.{{.Output.GoIdent.GoName}}): Promise<void>;
{{- end}}
{{- end}}
{{- end}}
  endpoints(): {{.Service.GoName}}EndpointInfo[];
}

/**
 * Configuration options for {{.Service.GoName}}NatsClient
 */
export interface {{.Service.GoName}}ClientOptions {
  subjectPrefix?: string;
  timeout?: number; // milliseconds
  clientInterceptors?: UnaryClientInterceptor[]; // Client-side interceptors
  jetstream?: any; // Optional JetStream client for KV/ObjectStore reads
}

/**
 * {{.Service.GoName}}NatsClient is the concrete implementation
 * The client sends requests over NATS using protobuf serialization.
 */
export class {{.Service.GoName}}NatsClient implements I{{.Service.GoName}}NatsClient {
  private readonly nc: NatsConnection;
  private readonly subjectPrefix: string;
  private readonly timeout?: number;
  private readonly interceptor?: UnaryClientInterceptor;
  private readonly js?: any; // Optional JetStream client

  /**
   * Create a new NATS client for {{.Service.GoName}}
   * @param nc - NATS connection
   * @param options - Client configuration options
   */
  constructor(nc: NatsConnection, options?: {{.Service.GoName}}ClientOptions) {
    this.nc = nc;
    this.subjectPrefix = options?.subjectPrefix || '{{.Options.SubjectPrefix}}';
    this.timeout = options?.timeout;
    this.js = options?.jetstream;
    
    // Chain client interceptors
    this.interceptor = options?.clientInterceptors
      ? chainUnaryClientInterceptors(options.clientInterceptors)
      : undefined;
  }

{{range .Service.Methods -}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
  /**
   * {{.GoName}} sends a {{.GoName}} request to the service via NATS.
   * @param request - The request message
   * @param opts - Optional request options
   * @returns Promise resolving to the response message
   * @throws {{$.Service.GoName}}Error if the request fails or the service returns an error
   */
  async {{ToLowerFirst .GoName}}(
    request: pb.{{.Input.GoIdent.GoName}},
    opts?: RequestOptions & { headers?: MsgHdrs }
  ): Promise<pb.{{.Output.GoIdent.GoName}}> {
    const method = '{{.GoName}}';
    
    // Define the invoker function that performs the actual NATS call
    const invoker: UnaryInvoker = async (m: string, req: any, reply: any, headers?: MsgHdrs, responseHeaders?: { value?: MsgHdrs }) => {
      const subject = `${this.subjectPrefix}.{{ToSnakeCase .GoName}}`;
      
      // Serialize request
      const data = pb.{{.Input.GoIdent.GoName}}.toBinary(req);
      
      // Send request with optional headers
      const requestOpts: RequestOptions = {
        ...opts,
        timeout: opts?.timeout || this.timeout,
        headers: headers || opts?.headers,
      };
      
      const msg = await this.nc.request(subject, data, requestOpts);
      
      // Store response headers for interceptor access
      if (responseHeaders && msg.headers) {
        responseHeaders.value = msg.headers;
      }
      
      // Check for error response
      const status = msg.headers?.get('Status');
      if (status) {
        const description = msg.headers?.get('Description') || 'Unknown error';
        throw new {{$.Service.GoName}}Error(status, method, description, msg.data);
      }
      
      // Deserialize response into reply object
      const decoded = pb.{{.Output.GoIdent.GoName}}.fromBinary(msg.data);
      Object.assign(reply, decoded);
    };

    const response = {} as pb.{{.Output.GoIdent.GoName}};
    const responseHeaders = { value: undefined as MsgHdrs | undefined };
    
    // Execute through interceptor chain if configured
    if (this.interceptor) {
      await this.interceptor(method, request, response, invoker, opts?.headers, responseHeaders);
    } else {
      await invoker(method, request, response, opts?.headers, responseHeaders);
    }
    
    return response;
  }

{{- if $endpointOpts.KVStore}}

  /**
   * Read a cached {{.GoName}} response directly from the KV Store.
   * @param key - The KV key matching the key_template pattern
   * @throws Error if JetStream is not configured or the key is not found
   */
  async get{{.GoName}}FromKV(key: string): Promise<pb.{{.Output.GoIdent.GoName}}> {
    if (!this.js) {
      throw new Error('JetStream not configured; pass jetstream option to enable KV reads');
    }
    const kv = await this.js.views.kv('{{$endpointOpts.KVStore.Bucket}}');
    const entry = await kv.get(key);
    if (!entry || !entry.value) {
      throw new Error(`KV key "${key}" not found in bucket "{{$endpointOpts.KVStore.Bucket}}"`);
    }
    return pb.{{.Output.GoIdent.GoName}}.fromBinary(entry.value);
  }

  /**
   * Write a {{.Output.GoIdent.GoName}} directly to the KV Store.
   * @param key - The KV key
   * @param val - The value to store
   * @throws Error if JetStream is not configured
   */
  async put{{.GoName}}ToKV(key: string, val: pb.{{.Output.GoIdent.GoName}}): Promise<void> {
    if (!this.js) {
      throw new Error('JetStream not configured; pass jetstream option to enable KV writes');
    }
    const kv = await this.js.views.kv('{{$endpointOpts.KVStore.Bucket}}');
    const data = pb.{{.Output.GoIdent.GoName}}.toBinary(val);
    await kv.put(key, data);
  }
{{- end}}

{{- if $endpointOpts.ObjectStore}}

  /**
   * Read a cached {{.GoName}} response directly from the Object Store.
   * @param key - The object key matching the key_template pattern
   * @throws Error if JetStream is not configured or the key is not found
   */
  async get{{.GoName}}FromObjectStore(key: string): Promise<pb.{{.Output.GoIdent.GoName}}> {
    if (!this.js) {
      throw new Error('JetStream not configured; pass jetstream option to enable Object Store reads');
    }
    const obj = await this.js.views.os('{{$endpointOpts.ObjectStore.Bucket}}');
    const data = await obj.getBlob(key);
    if (!data) {
      throw new Error(`Object "${key}" not found in bucket "{{$endpointOpts.ObjectStore.Bucket}}"`);
    }
    return pb.{{.Output.GoIdent.GoName}}.fromBinary(data);
  }

  /**
   * Write a {{.Output.GoIdent.GoName}} directly to the Object Store.
   * @param key - The object key
   * @param val - The value to store
   * @throws Error if JetStream is not configured
   */
  async put{{.GoName}}ToObjectStore(key: string, val: pb.{{.Output.GoIdent.GoName}}): Promise<void> {
    if (!this.js) {
      throw new Error('JetStream not configured; pass jetstream option to enable Object Store writes');
    }
    const obj = await this.js.views.os('{{$endpointOpts.ObjectStore.Bucket}}');
    const data = pb.{{.Output.GoIdent.GoName}}.toBinary(val);
    await obj.putBlob({ name: key }, data);
  }
{{- end}}

{{end -}}
{{end -}}
  /**
   * Returns information about all service endpoints this client can call.
   * This is useful for debugging, monitoring, and introspection.
   */
  endpoints(): {{.Service.GoName}}EndpointInfo[] {
    return [
{{- range .Service.Methods}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
      { name: '{{.GoName}}', subject: `${this.subjectPrefix}.{{ToSnakeCase .GoName}}` },
{{- end}}
{{- end}}
    ];
  }
}
