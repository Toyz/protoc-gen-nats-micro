{{- /* Client implementation */ -}}
/**
 * Endpoint information for {{.Service.GoName}}
 */
export interface {{.Service.GoName}}EndpointInfo {
  name: string;
  subject: string;
}

/**
 * {{.Service.GoName}}NatsClient is the interface for the NATS client
 * This interface allows for easier dependency injection and testing
 */
export interface I{{.Service.GoName}}NatsClient {
{{- range .Service.Methods}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
  {{ToLowerFirst .GoName}}(request: pb.{{.Input.GoIdent.GoName}}, opts?: RequestOptions): Promise<pb.{{.Output.GoIdent.GoName}}>;
{{- end}}
{{- end}}
  endpoints(): {{.Service.GoName}}EndpointInfo[];
}

/**
 * Configuration options for {{.Service.GoName}}NatsClient
 */
export interface {{.Service.GoName}}ClientOptions {
  subjectPrefix?: string;
  timeout?: number; // milliseconds
  clientInterceptors?: UnaryClientInterceptor[]; // Client-side interceptors
}

/**
 * {{.Service.GoName}}NatsClient is the concrete implementation
 * The client sends requests over NATS using protobuf serialization.
 */
export class {{.Service.GoName}}NatsClient implements I{{.Service.GoName}}NatsClient {
  private readonly nc: NatsConnection;
  private readonly subjectPrefix: string;
  private readonly timeout?: number;
  private readonly interceptor?: UnaryClientInterceptor;

  /**
   * Create a new NATS client for {{.Service.GoName}}
   * @param nc - NATS connection
   * @param options - Client configuration options
   */
  constructor(nc: NatsConnection, options?: {{.Service.GoName}}ClientOptions) {
    this.nc = nc;
    this.subjectPrefix = options?.subjectPrefix || '{{.Options.SubjectPrefix}}';
    this.timeout = options?.timeout;
    
    // Chain client interceptors
    this.interceptor = options?.clientInterceptors
      ? chainUnaryClientInterceptors(options.clientInterceptors)
      : undefined;
  }

{{range .Service.Methods -}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
  /**
   * {{.GoName}} sends a {{.GoName}} request to the service via NATS.
   * @param request - The request message
   * @param opts - Optional request options
   * @returns Promise resolving to the response message
   * @throws {{$.Service.GoName}}Error if the request fails or the service returns an error
   */
  async {{ToLowerFirst .GoName}}(
    request: pb.{{.Input.GoIdent.GoName}},
    opts?: RequestOptions & { headers?: MsgHdrs }
  ): Promise<pb.{{.Output.GoIdent.GoName}}> {
    const method = '{{.GoName}}';
    
    // Define the invoker function that performs the actual NATS call
    const invoker: UnaryInvoker = async (m: string, req: any, reply: any, headers?: MsgHdrs) => {
      const subject = `${this.subjectPrefix}.{{ToSnakeCase .GoName}}`;
      
      // Serialize request
      const data = pb.{{.Input.GoIdent.GoName}}.toBinary(req);
      
      // Send request with optional headers
      const requestOpts: RequestOptions = {
        ...opts,
        timeout: opts?.timeout || this.timeout,
        headers: headers || opts?.headers,
      };
      
      const msg = await this.nc.request(subject, data, requestOpts);
      
      // Check for error response
      const status = msg.headers?.get('Status');
      if (status) {
        const description = msg.headers?.get('Description') || 'Unknown error';
        throw new {{$.Service.GoName}}Error(status, method, description, msg.data);
      }
      
      // Deserialize response into reply object
      const decoded = pb.{{.Output.GoIdent.GoName}}.fromBinary(msg.data);
      Object.assign(reply, decoded);
    };

    const response = {} as pb.{{.Output.GoIdent.GoName}};
    
    // Execute through interceptor chain if configured
    if (this.interceptor) {
      await this.interceptor(method, request, response, invoker, opts?.headers);
    } else {
      await invoker(method, request, response, opts?.headers);
    }
    
    return response;
  }

{{end -}}
{{end -}}
  /**
   * Returns information about all service endpoints this client can call.
   * This is useful for debugging, monitoring, and introspection.
   */
  endpoints(): {{.Service.GoName}}EndpointInfo[] {
    return [
{{- range .Service.Methods}}
{{- $endpointOpts := GetEndpointOptions .}}
{{- if not $endpointOpts.Skip}}
      { name: '{{.GoName}}', subject: `${this.subjectPrefix}.{{ToSnakeCase .GoName}}` },
{{- end}}
{{- end}}
    ];
  }
}
